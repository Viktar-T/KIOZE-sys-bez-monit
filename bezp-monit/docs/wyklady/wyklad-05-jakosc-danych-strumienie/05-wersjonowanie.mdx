---
title: "Wersjonowanie konfiguracji i dashboardÃ³w"
sidebar_position: 5
---

import { 
  SlideContainer, 
  Slide, 
  KeyPoints, 
  SupportingDetails, 
  InstructorNotes,
  VisualSeparator,
  LearningObjective,
  KeyConcept,
  Example
} from '@site/src/components/SlideComponents';
import { InteractiveQuiz } from '@site/src/components/InteractiveQuiz';

<LearningObjective>
Po tej sekcji student potrafi:
- UzasadniÄ‡ potrzebÄ™ wersjonowania konfiguracji (reprodukowalnoÅ›Ä‡, audyt, rollback)
- ZaprojektowaÄ‡ Git workflow dla IaC (branches, pull requests, code review)
- ZaimplementowaÄ‡ CI/CD pipeline z walidacjÄ… (JSON lint, query tests, regression tests)
- OceniÄ‡ RPO/RTO requirements i zaprojektowaÄ‡ backup strategy (3-2-1 rule)
- OdtworzyÄ‡ system po awarii z Git repository (&lt;30 min RTO)
</LearningObjective>

<SlideContainer>

<Slide title="ğŸ§¾ Configuration as Code (CaC) â€“ dlaczego wersjonowaÄ‡?" type="info">

<KeyPoints title="ğŸ“‹ Problem: Manual configuration = chaos">

**Scenario bez wersjonowania:**

**Timeline disaster:**
- **Day 0**: Admin creates Grafana dashboard manually (clicks, 2 hours work)
- **Week 1**: Colleague modifies dashboard (adds panel, changes query) â†’ no tracking kto/kiedy/dlaczego
- **Month 2**: Dashboard breaks (query error after InfluxDB schema change) â†’ no history, nie moÅ¼na rollback
- **Month 6**: Grafana server crashes (disk failure) â†’ **dashboard lost** (no backup)
- **Recovery**: Recreate from memory? Screenshots? Email attachments? **Impossible** (2+ days work, incomplete)

**Impact:**
- **Lost knowledge**: No audit trail (who changed what, when, why)
- **No reproducibility**: Cannot recreate configuration (tribal knowledge)
- **No rollback**: Cannot revert to previous working version (break it = fix it manually lub rebuild)
- **No DR**: Disaster recovery = start from scratch (days of downtime)

---

### **Solution: Configuration as Code (stored in Git)**

**Wersjonowanie** = treating configuration as **source code** (Git version control).

**Benefits:**

**1. ReprodukowalnoÅ›Ä‡ (Reproducibility)**
- Git repo = single source of truth (all configs stored)
- Clone repo â†’ deploy â†’ **exact same configuration** (dev/staging/prod identical)
- Onboard new team member: `git clone` â†’ full context instantly

**2. Audyt zmian (Audit trail)**
- Every change = Git commit (who, when, what, why)
- Example commit message: `"Fixed inverter power query (bug #1234) - John Smith, 2024-07-15"`
- Full history: `git log` â†’ see all changes (forensics dla troubleshooting)

**3. Rollback (Revert to previous version)**
- Dashboard breaks â†’ `git revert <commit>` â†’ restore working version (seconds)
- Compare versions: `git diff` â†’ see exactly co siÄ™ zmieniÅ‚o

**4. Code review (Peer validation)**
- Pull request (PR) workflow â†’ colleague reviews before merge
- Catch errors early (typo in query, wrong threshold) â†’ prevent production issues

**5. Disaster recovery (DR)**
- Server crash â†’ `git clone` + redeploy â†’ **RTO &lt;30 min** (vs. days manual rebuild)
- Backup = Git repo (distributed, multiple copies: GitHub, GitLab, on-prem)

**6. Multi-environment consistency**
- Same config (Git), different variables (dev/staging/prod)
- Example: Dashboard template with `$environment` variable â†’ consistent across all

</KeyPoints>

<KeyConcept title="Co wersjonowaÄ‡? (Scope of version control)">

**Everything that defines system behavior:**

### **1. Monitoring stack configs**

**Grafana:**
- Datasources (`/etc/grafana/provisioning/datasources/*.yaml`)
- Dashboards (`/etc/grafana/provisioning/dashboards/*.json`)
- Alert rules, contact points, notification policies
- Users, teams, folders, permissions (YAML)

**InfluxDB:**
- Retention policies (SQL scripts)
- Continuous queries (SQL scripts)
- Database creation scripts
- User management (authentication, authorization)

**MQTT broker (Mosquitto):**
- `mosquitto.conf` (broker config)
- ACL file (authorization rules)
- TLS certificates (paths, not private keys! Use secret manager)

**Telegraf:**
- `telegraf.conf` (input/output plugins, transformations)

---

### **2. Infrastructure configs**

**Docker Compose / Kubernetes manifests:**
```yaml
# docker-compose.yml (versioned in Git)
version: '3.8'
services:
  mosquitto:
    image: eclipse-mosquitto:2.0
    volumes:
      - ./mosquitto.conf:/mosquitto/config/mosquitto.conf
      - ./acl:/mosquitto/config/acl
  
  influxdb:
    image: influxdb:2.7
    environment:
      INFLUX_DB: ${INFLUX_DB}  # Variable from .env file (not in Git)
  
  grafana:
    image: grafana/grafana:10.2
    volumes:
      - ./provisioning:/etc/grafana/provisioning
```

**Ansible playbooks / Terraform:**
- Infrastructure as Code (server provisioning, network config)

---

### **3. Application code**

**Data processing scripts:**
- Python scripts (data validation, transformation, ETL)
- SQL queries (KPI calculation, reporting)

**Edge gateway code:**
- Modbus â†’ MQTT bridge (configuration, mapping)

---

### **4. Documentation**

**Runbooks, SOPs (Standard Operating Procedures):**
- Incident response procedures
- Maintenance checklists
- Troubleshooting guides

**Architecture diagrams:**
- System architecture (Mermaid, draw.io source)
- Network topology

---

### **NOT to version (Secrets):**

**âŒ Do NOT commit to Git:**
- Passwords, API keys, tokens (use secret managers: HashiCorp Vault, AWS Secrets Manager)
- Private TLS certificates/keys (use certificate managers)
- `.env` files with secrets (use `.env.example` template instead)

**How to handle secrets:**
```bash
# .gitignore (prevent accidental commit)
.env
*.key
*.pem
passwords.txt

# .env.example (template, versioned in Git)
INFLUX_PASSWORD=changeme
MQTT_PASSWORD=changeme

# Actual .env (NOT versioned, stored securely)
INFLUX_PASSWORD=SecurePassword123!
MQTT_PASSWORD=AnotherSecure456!
```

</KeyConcept>

<SupportingDetails title="ğŸ“‚ Git repository structure â€“ organization best practices">

**Example repository layout:**

```
solar-monitoring/
â”œâ”€â”€ README.md                       # Overview, setup instructions
â”œâ”€â”€ .gitignore                      # Exclude secrets, build artifacts
â”œâ”€â”€ docker-compose.yml              # Container orchestration
â”œâ”€â”€ .env.example                    # Environment variables template
â”‚
â”œâ”€â”€ grafana/
â”‚   â”œâ”€â”€ provisioning/
â”‚   â”‚   â”œâ”€â”€ datasources/
â”‚   â”‚   â”‚   â”œâ”€â”€ influxdb.yaml      # InfluxDB datasource
â”‚   â”‚   â”‚   â””â”€â”€ prometheus.yaml    # (optional) Prometheus
â”‚   â”‚   â”œâ”€â”€ dashboards/
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboards.yaml    # Provider config
â”‚   â”‚   â”‚   â””â”€â”€ solar-farm/
â”‚   â”‚   â”‚       â”œâ”€â”€ overview.json  # Farm overview dashboard
â”‚   â”‚   â”‚       â”œâ”€â”€ inverter.json  # Inverter detail
â”‚   â”‚   â”‚       â””â”€â”€ alarms.json    # Alarms dashboard
â”‚   â”‚   â””â”€â”€ alerting/
â”‚   â”‚       â”œâ”€â”€ contact_points.yaml
â”‚   â”‚       â””â”€â”€ notification_policies.yaml
â”‚   â””â”€â”€ grafana.ini                 # Grafana server config
â”‚
â”œâ”€â”€ influxdb/
â”‚   â”œâ”€â”€ init-scripts/
â”‚   â”‚   â”œâ”€â”€ 01-create-db.sql       # Database creation
â”‚   â”‚   â”œâ”€â”€ 02-retention-policies.sql
â”‚   â”‚   â””â”€â”€ 03-continuous-queries.sql
â”‚   â””â”€â”€ influxdb.conf               # InfluxDB config
â”‚
â”œâ”€â”€ mosquitto/
â”‚   â”œâ”€â”€ mosquitto.conf              # Broker config
â”‚   â”œâ”€â”€ acl                         # Authorization rules
â”‚   â””â”€â”€ certs/                      # TLS certificates (paths only)
â”‚       â””â”€â”€ README.md               # Instructions dla cert generation
â”‚
â”œâ”€â”€ telegraf/
â”‚   â””â”€â”€ telegraf.conf               # Telegraf config
â”‚
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ backup.sh                   # Backup script (InfluxDB, Grafana)
â”‚   â”œâ”€â”€ restore.sh                  # Restore script
â”‚   â””â”€â”€ validate.sh                 # CI validation script
â”‚
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ architecture.md             # System architecture
â”‚   â”œâ”€â”€ runbook.md                  # Operations runbook
â”‚   â””â”€â”€ troubleshooting.md          # Common issues + solutions
â”‚
â””â”€â”€ .github/                        # GitHub-specific
    â””â”€â”€ workflows/
        â””â”€â”€ ci.yml                  # CI/CD pipeline
```

**Benefits organizacji:**
- **Separation of concerns**: Each component in dedicated directory
- **Self-documenting**: Structure mirrors system architecture
- **Easy navigation**: Team members quickly find configs
- **Scalability**: Add new components without restructuring

</SupportingDetails>

<Example title="Git workflow â€“ branches, pull requests, code review">

**Workflow: GitFlow variant (simplified dla ops team)**

### **Branch strategy:**

```
main (production)
â”œâ”€â”€ develop (staging)
â”‚   â”œâ”€â”€ feature/add-farm12-dashboard
â”‚   â”œâ”€â”€ feature/update-alert-thresholds
â”‚   â””â”€â”€ hotfix/fix-query-syntax-error
```

**Branches:**

**1. `main`** (protected, production-ready)
- Always stable (deploys to production)
- Direct commits **forbidden** (only via PR from `develop`)
- Tagged releases: `v1.0.0`, `v1.1.0`, ...

**2. `develop`** (integration, staging)
- Integration branch (features merge here first)
- Deploys to staging environment (test before production)
- Regularly merged to `main` (after validation)

**3. `feature/*`** (short-lived, task-specific)
- One feature per branch (e.g., `feature/add-farm12-dashboard`)
- Created from `develop`, merged back to `develop` via PR
- Deleted after merge (keep repo clean)

**4. `hotfix/*`** (emergency fixes)
- Critical bugs in production (bypass `develop` â†’ merge directly to `main`)
- Example: Dashboard query error causing alerts to fail
- Also merge to `develop` (keep in sync)

---

### **Workflow example: Add new dashboard dla Farm_12**

**Step 1: Create feature branch**
```bash
git checkout develop
git pull origin develop  # Sync latest changes
git checkout -b feature/add-farm12-dashboard
```

**Step 2: Make changes (add dashboard JSON)**
```bash
# Create new dashboard
cp grafana/provisioning/dashboards/solar-farm/template.json \
   grafana/provisioning/dashboards/solar-farm/farm12.json

# Edit farm12.json (replace $farm_id with Farm_12, customize panels)
vim grafana/provisioning/dashboards/solar-farm/farm12.json

# Test locally (Docker Compose)
docker-compose up -d
# Open Grafana, verify dashboard works
```

**Step 3: Commit changes**
```bash
git add grafana/provisioning/dashboards/solar-farm/farm12.json
git commit -m "Add Farm_12 overview dashboard

- Cloned from template
- Customized panels: power, energy, alarms
- Tested locally, data flowing correctly

Closes #456"  # Reference ticket/issue number
```

**Step 4: Push to remote + create Pull Request (PR)**
```bash
git push origin feature/add-farm12-dashboard
```

**On GitHub/GitLab:**
- Create PR: `feature/add-farm12-dashboard` â†’ `develop`
- Title: "Add Farm_12 overview dashboard"
- Description: What changed, why, testing done
- Assign reviewer (colleague)

---

### **Step 5: Code review (colleague reviews PR)**

**Reviewer checks:**
- **JSON syntax valid?** (CI should validate, but manual check nie boli)
- **Query correctness?** (InfluxQL syntax, correct measurement/tags)
- **Naming conventions?** (consistent with other dashboards)
- **Documentation?** (comment explaining complex queries)
- **Testing evidence?** (screenshot showing dashboard works)

**Review outcome:**
- **Approved**: Reviewer clicks "Approve" â†’ merge to `develop`
- **Changes requested**: Reviewer comments (e.g., "Fix typo in panel title") â†’ author updates â†’ re-review

---

### **Step 6: Merge to `develop`**
```bash
# GitHub UI: Click "Merge pull request" (squash commits optional)
# Or command line:
git checkout develop
git merge --no-ff feature/add-farm12-dashboard  # --no-ff preserves history
git push origin develop
```

**Automated deployment (CI/CD):**
- Push to `develop` triggers CI pipeline
- Validates JSON, deploys to **staging environment**
- Ops team tests in staging (smoke tests)

---

### **Step 7: Promote to production (`develop` â†’ `main`)**

After staging validation (1-7 days typical):
```bash
git checkout main
git merge develop
git tag v1.5.0  # Semantic versioning
git push origin main --tags
```

**Automated deployment:**
- Push to `main` triggers production deployment
- Grafana reloads provisioning â†’ Farm_12 dashboard live in production

---

**Timeline summary:**
- Feature branch created: Day 0
- PR created: Day 0 (after local testing)
- Code review: Day 1 (colleague reviews within 1 business day)
- Merged to `develop`, deployed to staging: Day 1
- Tested in staging: Day 1-3
- Merged to `main`, deployed to production: Day 3
- **Total: 3 days** (safe, validated process)

**Comparison to direct production change:**
- Manual change in Grafana UI: 10 min
- **But**: No review, no testing, no rollback â†’ high risk (1 in 10 changes breaks something)
- Git workflow: 3 days, but **safe** (review + staging catch 95% issues)

</Example>

<InstructorNotes>

**Czas**: 18-20 min

**Przebieg**:
1. Dlaczego wersjonowaÄ‡ (4 min) â€“ problem manual config, benefits CaC
2. Co wersjonowaÄ‡ (4 min) â€“ monitoring configs, infrastructure, docs (NOT secrets!)
3. Repo structure (3 min) â€“ example layout, organization best practices
4. Git workflow (5 min) â€“ branches, PR, code review (full example)
5. Q&A (2 min)

**Punkty kluczowe**:
- **Configuration = code** (treat it like software development)
- **Git = single source of truth** (all configs, full history)
- **Code review** (PR workflow) catches errors early (95% issues prevented)
- **Staging environment** (test before production) mandatory dla safety
- **NOT commit secrets** to Git (passwords, keys) â€“ use secret managers

**Demonstracja praktyczna**:
- Live Git workflow: Create branch, commit, push, PR (GitHub UI)
- Show PR review: Comment on code, request changes, approve
- CI/CD pipeline: Show GitHub Actions logs (validate JSON, deploy to staging)
- Rollback demo: `git revert` â†’ redeploy â†’ dashboard restored (seconds)

**MateriaÅ‚y pomocnicze**:
- Example Git repo: Solar Monitoring (GitHub template)
- Git cheatsheet (common commands)
- GitHub Flow documentation (simplified workflow)
- CI/CD pipeline templates (GitHub Actions, GitLab CI)

**Typowe bÅ‚Ä™dy studenckie**:
- **Committing secrets** (passwords in Git) â€“ use .gitignore + secret managers!
- **No code review** (merge own PR) â€“ defeats purpose (catch errors)
- **Large commits** (change 20 files at once) â€“ hard to review; split into small PRs
- **Poor commit messages** ("fix", "update") â€“ be descriptive ("Fix query timeout in power panel, closes #123")

**Pytania studenckie**:
- Q: Czy Git nie jest overkill dla maÅ‚ego teamu (2-3 osoby)?
- A: NO. Even 1-person team benefits (audyt, rollback, DR). Git overhead minimal (learn once, use forever). Alternative (no Git) = chaos after 6 months.

- Q: Co z large binary files (e.g., database backups, images)?
- A: **Git LFS** (Large File Storage) dla binaries >10 MB. Lub: Store outside Git (S3, NAS), link in README. Git designed dla text files (configs, code), nie large binaries.

- Q: Jak handle merge conflicts (2 people edit same dashboard)?
- A: **Conflicts happen** (Git shows conflict markers). **Resolution**: (1) Communicate (Slack: "I'm editing farm overview dashboard"), (2) Small PRs (reduce overlap), (3) Manual merge (choose which change to keep). **Prevention > cure**.

</InstructorNotes>

</Slide>

<VisualSeparator type="technical" />

<Slide title="ğŸ› ï¸ CI/CD pipeline â€“ automated validation & deployment" type="tip">

<KeyConcept title="Continuous Integration / Continuous Deployment (CI/CD)">

**CI/CD** = automation pipeline triggered by Git events (push, PR).

**Stages:**

```mermaid
graph LR
    A[Git Push<br/>feature branch] --> B[CI: Validate<br/>JSON lint, tests]
    B -->|PASS| C[Deploy to<br/>Staging]
    B -->|FAIL| D[Block merge<br/>notify author]
    
    C --> E[Manual testing<br/>staging env]
    E -->|OK| F[Merge to main<br/>PR approved]
    F --> G[CD: Deploy to<br/>Production]
    
    style B fill:#ffeb99
    style C fill:#87ceeb
    style G fill:#90ee90
    style D fill:#ff9999
```

**Benefits:**
- **Automated validation**: Catch errors before deploy (JSON syntax, query errors)
- **Fast feedback**: PR author notified within 2-5 min (CI runs automatically)
- **Consistent deployment**: Same process every time (no manual steps, no human error)
- **Rollback-friendly**: Tagged releases â†’ easy revert (`git checkout v1.4.0` â†’ redeploy)

</KeyConcept>

<SupportingDetails title="ğŸ” CI pipeline stages â€“ validation steps">

### **Stage 1: Syntax validation (JSON lint)**

**Goal**: Catch syntax errors (malformed JSON, missing commas).

**GitHub Actions workflow** (`.github/workflows/ci.yml`):
```yaml
name: CI - Validate Configs

on:
  pull_request:
    branches: [develop, main]
  push:
    branches: [develop, main]

jobs:
  validate-json:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Validate Grafana dashboards (JSON)
        run: |
          for file in grafana/provisioning/dashboards/**/*.json; do
            echo "Validating $file"
            jq empty "$file" || exit 1  # jq = JSON processor, "empty" = validate only
          done
      
      - name: Validate YAML configs
        run: |
          pip install yamllint
          yamllint grafana/provisioning/datasources/*.yaml
          yamllint grafana/provisioning/alerting/*.yaml
```

**Output (if error):**
```
Error: Validating grafana/provisioning/dashboards/solar-farm/farm12.json
parse error: Expected separator between values at line 45, column 12
âŒ CI failed â†’ PR blocked (cannot merge until fixed)
```

---

### **Stage 2: Query validation (InfluxDB queries)**

**Goal**: Catch query errors (typos, wrong measurement names).

**Test script** (`scripts/validate-queries.sh`):
```bash
#!/bin/bash
# Extract queries from dashboard JSON, test against InfluxDB

for dashboard in grafana/provisioning/dashboards/**/*.json; do
  # Extract InfluxQL queries (jq filter)
  queries=$(jq -r '.panels[].targets[].query' "$dashboard" 2>/dev/null)
  
  for query in $queries; do
    # Test query against staging InfluxDB (dry-run, EXPLAIN)
    curl -G 'http://influxdb-staging:8086/query' \
      --data-urlencode "db=solar_farm" \
      --data-urlencode "q=EXPLAIN $query" \
      -u "$INFLUX_USER:$INFLUX_PASSWORD" || {
        echo "âŒ Query error in $dashboard: $query"
        exit 1
      }
  done
done

echo "âœ… All queries valid"
```

**CI workflow integration:**
```yaml
- name: Validate InfluxDB queries
  env:
    INFLUX_USER: ${{ secrets.INFLUX_USER }}
    INFLUX_PASSWORD: ${{ secrets.INFLUX_PASSWORD }}
  run: ./scripts/validate-queries.sh
```

---

### **Stage 3: Regression tests (KPI calculations)**

**Goal**: Ensure dashboard changes don't break KPI calculations.

**Test case example** (`tests/test_pr_calculation.py`):
```python
import pytest
import requests

def test_pr_calculation_accuracy():
    """Test PR (Performance Ratio) calculation in overview dashboard"""
    
    # Query Grafana API (render panel, get result)
    response = requests.get(
        'http://grafana-staging:3000/api/dashboards/uid/solar-farm-overview',
        auth=('admin', 'admin')
    )
    dashboard = response.json()
    
    # Extract PR panel query
    pr_panel = next(p for p in dashboard['dashboard']['panels'] if p['title'] == 'PR (%)')
    pr_query = pr_panel['targets'][0]['query']
    
    # Expected query (regression baseline)
    expected_query = 'SELECT mean("E_actual") / mean("E_expected") * 100 FROM "energy" WHERE $timeFilter'
    
    assert pr_query == expected_query, f"PR query changed unexpectedly: {pr_query}"

def test_pr_value_range():
    """Test PR value within realistic range (70-95%)"""
    
    # Query InfluxDB directly (last 24h PR)
    response = requests.get(
        'http://influxdb-staging:8086/query',
        params={
            'db': 'solar_farm',
            'q': 'SELECT mean("PR") FROM "kpi" WHERE time > now() - 24h'
        },
        auth=('grafana', 'password')
    )
    
    pr_value = response.json()['results'][0]['series'][0]['values'][0][1]
    
    assert 70 <= pr_value <= 95, f"PR value {pr_value}% outside realistic range (70-95%)"

# Run tests
# pytest tests/test_pr_calculation.py
```

**CI integration:**
```yaml
- name: Run regression tests
  run: |
    pip install pytest requests
    pytest tests/ --junitxml=test-results.xml
  
- name: Publish test results
  uses: actions/upload-artifact@v3
  with:
    name: test-results
    path: test-results.xml
```

---

### **Stage 4: Deploy to staging (if all tests pass)**

**Deployment script** (`scripts/deploy-staging.sh`):
```bash
#!/bin/bash
# Deploy Grafana provisioning to staging environment

# 1. Sync provisioning directory
rsync -avz grafana/provisioning/ \
  staging-server:/etc/grafana/provisioning/

# 2. Restart Grafana (reload provisioning)
ssh staging-server "systemctl restart grafana-server"

# 3. Wait dla Grafana startup (health check)
for i in {1..30}; do
  curl -f http://staging-server:3000/api/health && break
  echo "Waiting dla Grafana... ($i/30)"
  sleep 2
done

echo "âœ… Deployed to staging: http://staging-server:3000"
```

**CI integration:**
```yaml
- name: Deploy to staging
  if: github.ref == 'refs/heads/develop'  # Only on develop branch
  run: ./scripts/deploy-staging.sh
```

</SupportingDetails>

<Example title="Disaster recovery: Restore from Git in 30 minutes (RTO)">

**Scenario**: Grafana server hardware failure (disk crash), complete data loss.

**Recovery objectives:**
- **RTO (Recovery Time Objective)**: &lt;30 min (max downtime tolerable)
- **RPO (Recovery Point Objective)**: &lt;15 min (max data loss tolerable)

---

### **Recovery procedure:**

**T+0 min: Incident detected**
- Monitoring alerts: "Grafana server unreachable"
- Ops team confirms: Server unresponsive (hardware failure)

**T+2 min: Decision â€“ restore from Git (DR plan activated)**

**T+5 min: Provision new server (cloud or spare hardware)**
```bash
# Launch new VM (AWS EC2, Azure, lub on-prem spare)
# Install base OS (Ubuntu 22.04), Docker

sudo apt update
sudo apt install -y docker.io docker-compose git
```

**T+10 min: Clone Git repository (all configs)**
```bash
git clone https://github.com/company/solar-monitoring.git
cd solar-monitoring
```

**T+12 min: Restore secrets (from secret manager)**
```bash
# Retrieve secrets from HashiCorp Vault / AWS Secrets Manager
vault kv get -field=password secret/influxdb/grafana > .env
# .env now contains INFLUX_PASSWORD, MQTT_PASSWORD, etc.
```

**T+15 min: Deploy monitoring stack (Docker Compose)**
```bash
docker-compose up -d

# Services starting:
# - Mosquitto (MQTT broker)
# - InfluxDB (TSDB)
# - Telegraf (data collector)
# - Grafana (visualization)
```

**T+20 min: Verify services healthy**
```bash
# Check all containers running
docker-compose ps

# Check Grafana dashboards auto-loaded (provisioned from Git)
curl http://localhost:3000/api/dashboards/uid/solar-farm-overview

# Check InfluxDB data (restored from backup, separate process)
influx -execute 'SHOW DATABASES'
```

**T+25 min: Update DNS (point to new server)**
```bash
# Update DNS A record: grafana.solarfarm.com â†’ new IP
# (DNS TTL = 5 min, propagation within 5 min)
```

**T+30 min: Service restored âœ…**
- Grafana accessible @ http://grafana.solarfarm.com:3000
- All dashboards present (provisioned from Git)
- Data flowing (MQTT â†’ InfluxDB â†’ Grafana)

---

### **Data loss assessment (RPO):**

**InfluxDB data:**
- **Last backup**: T-2 hours (automated backup every 2 hours)
- **Data loss**: 2 hours raw data (**NOT** 15 min target!)

**Improvement needed:**
- **Continuous replication** (InfluxDB Enterprise lub manual replication)
- **Example**:
  ```bash
  # Primary InfluxDB â†’ Replica (async replication, <1 min lag)
  influx -execute 'CREATE SUBSCRIPTION "replica" ON "solar_farm"."raw_7d" DESTINATIONS ALL "http://influxdb-replica:8086"'
  ```
- **With replication**: RPO = **&lt;1 min** (acceptable!)

---

### **Lessons learned:**

**What went well:**
- âœ… Git repo = single source of truth (all configs recovered instantly)
- âœ… Docker Compose = consistent deployment (no manual config, click-ops)
- âœ… Provisioning = dashboards auto-loaded (no manual recreation)
- âœ… RTO met: **30 min** (target achieved)

**What needs improvement:**
- âŒ RPO violated: 2 hours data loss (> 15 min target)
- **Action**: Implement InfluxDB replication (continuous backup)
- âŒ Secrets manual retrieval (5 min delay)
- **Action**: Automate secret injection (CI/CD pipeline fetches from Vault)

**Final RTO/RPO (after improvements):**
- **RTO**: 20 min (automation improvements, -10 min)
- **RPO**: &lt;1 min (continuous replication, -119 min)

</Example>

<InstructorNotes>

**Czas**: 18-20 min

**Przebieg**:
1. CI/CD concept (3 min) â€“ stages, benefits (automated validation)
2. CI pipeline stages (6 min) â€“ JSON lint, query validation, regression tests
3. Deployment stages (3 min) â€“ staging â†’ production workflow
4. Disaster recovery example (5 min) â€“ restore from Git (30 min RTO)
5. Q&A (2 min)

**Punkty kluczowe**:
- **CI = automated gatekeeper** (catch errors before deploy)
- **Regression tests** (KPI calculations) critical (prevent silent bugs)
- **Staging environment** mandatory (test before production)
- **DR from Git** = fast recovery (RTO &lt;30 min achievable)
- **RPO vs. RTO** trade-off (continuous replication expensive, backup lag cheaper)

**Demonstracja praktyczna**:
- Live CI pipeline: Trigger GitHub Actions (push to branch), show logs (validate â†’ deploy)
- Intentional error: Commit broken JSON, show CI failure (PR blocked)
- Fix error: Commit fix, CI passes, PR mergeable (green checkmark)
- DR simulation: `docker-compose down -v` (destroy), `git clone` + `docker-compose up` (restore in 5 min local)

**MateriaÅ‚y pomocnicze**:
- Example CI/CD workflows (GitHub Actions, GitLab CI templates)
- Regression test examples (pytest, integration tests)
- DR runbook (step-by-step recovery procedure)
- RTO/RPO calculator (spreadsheet â€“ input requirements, output architecture recommendations)

**Typowe bÅ‚Ä™dy studenckie**:
- **No regression tests** (only syntax validation) â€“ JSON valid â‰  dashboard works correctly
- **Skipping staging** (deploy directly to production) â€“ risky, errors discovered by users
- **No backup testing** (assume backups work) â€“ test restore procedure (quarterly drill)
- **Confusing RPO/RTO**: RTO = time to restore service (downtime), RPO = data loss (backup frequency)

**Pytania studenckie**:
- Q: CI pipeline slow (10 min) â€“ delays development. Jak przyspieszyÄ‡?
- A: **Optimization**: (1) Parallel jobs (validate JSON, YAML, queries simultaneously), (2) Cache dependencies (pip, npm), (3) Skip redundant tests (only test changed files). **Trade-off**: Speed vs. thoroughness (don't skip critical tests).

- Q: Staging environment = duplicate infrastructure (expensive). Alternatywy?
- A: **Options**: (1) Shared staging (multiple teams, scheduled deployments), (2) Lightweight staging (single server, vs. production cluster), (3) Feature flags (deploy to production, enable dla subset users, test in production). **Risk**: Lightweight staging may miss production-specific issues (scale, load).

- Q: Secrets w Git (accidentally committed) â€“ jak remove completely?
- A: **Damage control**: (1) Revoke secret immediately (change password, rotate key), (2) Remove from Git history (`git filter-branch`, `BFG Repo-Cleaner`), (3) Force push (rewrite history), (4) Notify team (all clones contain secret, re-clone after cleanup). **Prevention**: Pre-commit hooks (block commits with secrets), `.gitignore` (secrets files), secret scanning (GitHub, GitGuardian).

</InstructorNotes>

</Slide>

<VisualSeparator type="default" />

<Slide title="ğŸ“ Quiz: Wersjonowanie, CI/CD, disaster recovery" type="info">

<InteractiveQuiz 
  questions={[
    {
      question: "Co NIE powinno byÄ‡ versioned w Git repository?",
      options: [
        "Grafana dashboard JSON files",
        "InfluxDB retention policy SQL scripts",
        ".env file with INFLUX_PASSWORD=SecurePass123!",
        "Docker Compose YAML manifests"
      ],
      correctAnswer: 2,
      explanation: ".env z passwords = SECRET (NIE commit to Git). Use .env.example (template) + secret manager (Vault). Opcja (a), (b), (d) = configs (safe to version). Rule: If it's sensitive (password, key, token) â†’ NOT in Git."
    },
    {
      question: "Git workflow: Feature branch â†’ Pull Request â†’ Review. Reviewer finds critical bug. Co NAJPIERW?",
      options: [
        "Merge anyway (fix later in hotfix)",
        "Request changes (author fixes, re-review before merge)",
        "Reject PR (close, start over)",
        "Merge to staging (test in production)"
      ],
      correctAnswer: 1,
      explanation: "Code review purpose = catch bugs BEFORE merge. Request changes â†’ author fixes â†’ re-review â†’ merge (safe). Opcja (a) defeats review purpose (bug in production). Opcja (c) wasteful (rework entire PR). Opcja (d) staging = pre-production test (but review first, catch obvious bugs early)."
    },
    {
      question: "CI pipeline: JSON validation PASS, query validation FAIL (typo w measurement name). Co siÄ™ dzieje?",
      options: [
        "PR merge blocked (CI failed, cannot merge)",
        "PR merge allowed (warning tylko, nie blocker)",
        "Automatic fix (CI corrects typo, commits)",
        "Deploy to staging (test failures allowed)"
      ],
      correctAnswer: 0,
      explanation: "CI failure (any stage) = block merge (red X). Author must fix + push â†’ CI re-runs â†’ all stages PASS â†’ merge allowed. Opcja (b) dangerous (warnings ignored â†’ bugs in production). Opcja (c) nieprawda (CI validates, nie modyfikuje code). Opcja (d) nieprawda (staging only IF CI passes)."
    },
    {
      question: "RTO = 30 min, RPO = 15 min. Grafana crashes @ 14:00. Last backup @ 13:00. Recovery finishes @ 14:45. KtÃ³re violated?",
      options: [
        "RTO violated (45 min > 30 min target), RPO OK (60 min < 15 min)",
        "RPO violated (60 min > 15 min target), RTO OK (45 min < 30 min)",
        "BOTH violated (RTO: 45 min > 30, RPO: 60 min > 15)",
        "NEITHER violated (both within targets)"
      ],
      correctAnswer: 2,
      explanation: "RTO = recovery time = 14:45 - 14:00 = **45 min** (target 30) â†’ VIOLATED. RPO = data loss = 14:00 - 13:00 = **60 min** (target 15) â†’ VIOLATED. Opcja (c) correct. Improvement needed: Faster recovery (automation, DR rehearsal) + more frequent backups (continuous replication)."
    },
    {
      question: "Regression test: PR changes dashboard query, test fails (PR value now 105%, expected 70-95%). Co to oznacza?",
      options: [
        "Bug in PR (query broken, returns wrong result) â€“ author must fix",
        "Test outdated (baseline wrong) â€“ update test",
        "InfluxDB data corrupt â€“ restore backup",
        "Normal (PR value varies, test too strict) â€“ ignore test"
      ],
      correctAnswer: 0,
      explanation: "PR = 105% (impossible, >100%) â†’ clearly wrong result â†’ BUG in query. Author review query logic, fix, re-test. Opcja (b) possible ale unlikely (baseline 70-95% reasonable dla PR). Opcja (c) unrelated (test uses staging data, isolated). Opcja (d) dangerous (ignoring test defeats purpose; if test wrong, fix test, nie ignore)."
    }
  ]}
/>

:::tip Rekomendacja po quizie
JeÅ›li uzyskaÅ‚eÅ› &lt;80%, przejrzyj: (1) Secrets management (NOT in Git, use Vault), (2) Code review workflow (request changes â†’ fix â†’ merge), (3) CI blocking (failure = no merge), (4) RTO/RPO definitions (time to restore vs. data loss), (5) Regression tests (catch logic bugs, nie just syntax).
:::

</Slide>

</SlideContainer>

---

## Podsumowanie i wnioski

**Kluczowe punkty z tej sekcji:**

**Configuration as Code (wersjonowanie obowiÄ…zkowe)**:
   - Git = single source of truth (wszystkie configs, peÅ‚na historia)
   - Benefits: ReprodukowalnoÅ›Ä‡, audyt, rollback, DR (&lt;30 min RTO)
   - Zakres: Monitoring configs, infrastructure (IaC), docs (NOT secrets!)

**Git workflow (branches + code review)**:
   - Branches: `main` (production), `develop` (staging), `feature/*` (tasks)
   - Pull Request (PR) â†’ code review â†’ staging â†’ production (safe path)
   - Code review catches 95% issues before production (peer validation)

**CI/CD pipeline (automated validation)**:
   - Stages: JSON lint â†’ query validation â†’ regression tests â†’ deploy staging
   - CI failure = block merge (no broken configs to production)
   - Regression tests critical (KPI calculations, nie tylko syntax)

**Disaster recovery (Git = backup)**:
   - Restore procedure: Clone Git â†’ deploy â†’ RTO &lt;30 min (achievable)
   - RPO &lt;15 min: Continuous InfluxDB replication (vs. periodic backups)
   - DR rehearsal quarterly (test procedure, improve RTO/RPO)

**NastÄ™pne kroki:**
- Ä†wiczenie: Setup Git repo dla monitoring stack, create PR, code review
- Lab: Build CI pipeline (GitHub Actions, validate JSON/YAML)
- Przygotowanie: NastÄ™pna sekcja â€“ Podsumowanie WykÅ‚adu 05 (comprehensive review)

---

**Dodatkowe zasoby:**
- **Git**: Pro Git book (free, online), GitHub Flow documentation
- **CI/CD**: GitHub Actions docs, GitLab CI examples
- **Secrets management**: HashiCorp Vault, AWS Secrets Manager guides
- **Disaster recovery**: Google SRE book (Chapter 26: Data Integrity)


