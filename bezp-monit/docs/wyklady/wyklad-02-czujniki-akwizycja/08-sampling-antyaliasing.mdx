---
title: "PrÃ³bkowanie i antiâ€‘aliasing"
sidebar_position: 8
---

import { 
  SlideContainer, 
  Slide, 
  KeyPoints, 
  SupportingDetails, 
  InstructorNotes,
  VisualSeparator,
  LearningObjective,
  KeyConcept,
  Example
} from '@site/src/components/SlideComponents';
import { InteractiveQuiz } from '@site/src/components/InteractiveQuiz';

<LearningObjective>
Po tej sekcji student potrafi:
- ZastosowaÄ‡ twierdzenie Nyquista-Shannona do doboru czÄ™stotliwoÅ›ci prÃ³bkowania dla rÃ³Å¼nych sygnaÅ‚Ã³w
- ZaprojektowaÄ‡ system akwizycji z wÅ‚aÅ›ciwym filtrem anty-aliasing (typ, rzÄ…d, czÄ™stotliwoÅ›Ä‡ odciÄ™cia)
- OkreÅ›liÄ‡ optymalne parametry prÃ³bkowania dla aplikacji OZE (PV, wiatr, biogaz)
- ZdiagnozowaÄ‡ i naprawiÄ‡ problemy zwiÄ…zane z aliasing i niewystarczajÄ…cÄ… czÄ™stotliwoÅ›ciÄ… prÃ³bkowania
</LearningObjective>

<SlideContainer>

<Slide title="ğŸ“Š Twierdzenie Nyquista-Shannona â€“ fundament prÃ³bkowania" type="info">

<KeyPoints title="ğŸ“‹ Podstawy teorii prÃ³bkowania">

**Twierdzenie Nyquista-Shannona (1928/1949)**

Aby **wiernie zrekonstruowaÄ‡** sygnaÅ‚ ciÄ…gÅ‚y (analog) z prÃ³bek dyskretnych (digital), czÄ™stotliwoÅ›Ä‡ prÃ³bkowania musi speÅ‚niaÄ‡:

$$
f_{sample} \geq 2 \times f_{max}
$$

Gdzie:
- $f_{sample}$ â€“ czÄ™stotliwoÅ›Ä‡ prÃ³bkowania [Hz lub samples/s]
- $f_{max}$ â€“ maksymalna czÄ™stotliwoÅ›Ä‡ w sygnale [Hz]
- **CzÄ™stotliwoÅ›Ä‡ Nyquista**: $f_{Nyquist} = 2 \times f_{max}$

**W praktyce (ZAWSZE!):**

$$
f_{sample} \geq (2.5 - 5) \times f_{max}
$$

**Dlaczego zapas?**
1. **Filtry nie sÄ… idealne** â€“ Slope roll-off jest skoÅ„czony (-20 dB/dec dla 1st order, -80 dB/dec dla 4th order)
2. **Transition band** â€“ MiÄ™dzy passband a stopband jest przejÅ›cie (nie instant cut-off)
3. **Component tolerances** â€“ Rezystory/kondensatory majÄ… tolerancje Â±5-10%
4. **Temperature drift** â€“ CzÄ™stotliwoÅ›Ä‡ odciÄ™cia filtru zmienia siÄ™ z T

---

### Co siÄ™ dzieje przy f_sample < 2 Ã— f_max?

**ALIASING** â€“ wysokie czÄ™stotliwoÅ›ci "zawijajÄ… siÄ™" (fold back) i pojawiajÄ… jako **faÅ‚szywe** niskie czÄ™stotliwoÅ›ci.

**WzÃ³r na czÄ™stotliwoÅ›Ä‡ alias:**

$$
f_{alias} = |f_{signal} - n \times f_{sample}|
$$

Gdzie n = 1, 2, 3, ... (integer)

**PrzykÅ‚ad liczbowy:**
- SygnaÅ‚: f_signal = 4700 Hz (EMI z inwertera PWM)
- PrÃ³bkowanie: f_sample = 5000 Hz
- Alias: f_alias = |4700 - 1Ã—5000| = |4700 - 5000| = **300 Hz**

ADC "widzi" sygnaÅ‚ 300 Hz zamiast 4700 Hz!

**Graficzna ilustracja (sinusoid undersampling):**

JeÅ›li prÃ³bkujesz sinusoidÄ™ 900 Hz z f_sample = 1000 Hz, prÃ³bki "wyglÄ…dajÄ… jakby" pochodziÅ‚y z sinusoidy 100 Hz.

```
Original 900 Hz:  ~~~~~~~~~~~~~~~  (szybka oscylacja)
Samples @ 1 kHz:  * . . . * . . . * . . . * . . .
Alias 100 Hz:     \_____/         \_____/          (wolna oscylacja)
```

**Kluczowe:** Po prÃ³bkowaniu NIE DA SIÄ˜ odzyskaÄ‡ pierwotnej czÄ™stotliwoÅ›ci â€“ informacja jest nieodwracalnie utracona!

</KeyPoints>

<SupportingDetails title="ğŸ›ï¸ Strategia doboru f_sample dla rÃ³Å¼nych aplikacji">

### Metodologia 3-krokowa:

**Krok 1: OkreÅ›l f_max (maksymalna interesujÄ…ca czÄ™stotliwoÅ›Ä‡)**

Analiza spektrum sygnaÅ‚u:
- **PV (prÄ…d/napiÄ™cie stringÃ³w)**: f_max â‰ˆ 1-5 Hz (wolne zmiany, cloud transients)
- **Wibracje main bearing**: f_max â‰ˆ 100-500 Hz (BPFO, BPFI harmoniczne)
- **Wibracje gearbox high-speed**: f_max â‰ˆ 5-10 kHz (mesh frequency harmonics)
- **Gazy (Hâ‚‚S process control)**: f_max â‰ˆ 0.01-0.1 Hz (bardzo wolne zmiany)
- **Acoustic emission (bearing cracks)**: f_max â‰ˆ 50-100 kHz (ultrasonic)

**Krok 2: Wybierz zapas (oversampling ratio)**

$$
OSR = \frac{f_{sample}}{2 \cdot f_{max}}
$$

Typowe wartoÅ›ci:
- **OSR = 1.25-1.5Ã—** (barely Nyquist, wymaga bardzo stromego filtru â€“ 8th order+)
- **OSR = 2-3Ã—** (standard w przemyÅ›le, 4th order Butterworth wystarczy)
- **OSR = 5-10Ã—** (conservative, prosty filtr 2nd order OK)

**Krok 3: Dobierz f_sample z dostÄ™pnych wartoÅ›ci ADC**

ADC majÄ… dyskretne f_sample (czÄ™sto potÄ™gi 2):
- 1 kHz, 2 kHz, 5 kHz, 10 kHz, 20 kHz, 50 kHz, 100 kHz, ...

**Zawsze wybieraj najbliÅ¼szÄ… WYÅ»SZÄ„** wartoÅ›Ä‡ dostÄ™pnÄ….

---

### Parametry prÃ³bkowania dla typowych aplikacji OZE:

| Aplikacja | f_max | f_sample recommended | ADC resolution | Passband filter | PrzykÅ‚ad sprzÄ™tu |
|-----------|-------|----------------------|----------------|-----------------|------------------|
| **PV string monitoring** | 5 Hz | 50-100 Hz | 16-bit | 10 Hz LP | NI USB-6009 |
| **Pyranometer (G_POA)** | 1 Hz | 10 Hz | 16-bit | 2 Hz LP | Campbell CR1000 |
| **Temperature (PT1000)** | 0.1 Hz | 1 Hz | 24-bit | 0.2 Hz LP | Datataker DT85 |
| **Vibration (low freq)** | 500 Hz | 2.5 kHz | 24-bit | 1 kHz LP, Butterworth 4th | PCB 356A15 + NI 9234 |
| **Vibration (high freq)** | 10 kHz | 50 kHz | 24-bit | 20 kHz LP, Butterworth 6th | BrÃ¼el & KjÃ¦r 4507 + LAN-XI |
| **Gas sensors (Hâ‚‚S)** | 0.05 Hz | 1 Hz | 16-bit | 0.1 Hz LP | Modbus RTU @ 1s interval |
| **SCADA trends** | 0.01 Hz | 0.1 Hz (10s) | 16-bit | N/A (juÅ¼ wolne) | InfluxDB aggregation |

**Wnioski:**
- **Wolne procesy** (temp, gazy): f_sample = 1-10 Hz wystarczy
- **Dynamiczne procesy** (wibracje): f_sample = kilkadziesiÄ…t kHz
- **Zawsze filtr anty-aliasing!** (poza bardzo wolnymi: &lt;0.1 Hz)

</SupportingDetails>

<InstructorNotes>

**Czas**: 14-16 min

**Przebieg**:
1. Twierdzenie Nyquista â€“ definicja i przykÅ‚ad liczbowy (4 min)
2. Aliasing â€“ co to jest i dlaczego nieodwracalny (3 min) â€“ uÅ¼yj grafiki/animacji
3. Metodologia 3-krokowa doboru f_sample (4 min)
4. Tabela parametrÃ³w dla OZE (2 min) â€“ omÃ³w typowe wartoÅ›ci
5. Q&A (2 min)

**Punkty kluczowe**:
- **Nyquist to MINIMUM teoretyczne** â€“ zawsze 2.5-5Ã— zapas w praktyce
- **Aliasing to nieodwracalna strata** â€“ nie moÅ¼na cofnÄ…Ä‡ po prÃ³bkowaniu
- f_sample zaleÅ¼y od f_max sygnaÅ‚u (nie od "jak szybko chcemy danych"!)
- ADC resolution (bit depth) â‰  f_sample (to rÃ³Å¼ne parametry!)

**Demonstracja praktyczna**:
- Animacja aliasing (Python/Matlab): sygnaÅ‚ 900 Hz prÃ³bkowany @ 1 kHz â†’ wyglÄ…da jak 100 Hz
- Oscyloskop: undersampling sinusoidy â€“ wizualizacja envelope
- Audio playback: sound @ 4 kHz â†’ sampled @ 5 kHz â†’ playback sounds like 1 kHz (perceptible)

**MateriaÅ‚y pomocnicze**:
- Lyons, "Understanding Digital Signal Processing" (Chapter 2: Sampling)
- Application note: "ADC Sampling Frequency & Aliasing" (TI, AN-282)
- Python script: aliasing_demo.py (https://github.com/.../aliasing-visualization)
- Interactive tool: Nyquist demo (Wolfram Alpha widget)

**Typowe bÅ‚Ä™dy studenckie**:
- MyÅ›lenie, Å¼e f_sample = 2Ã— f_max wystarczy w praktyce â€“ NO! To MINIMUM teoretyczne
- Mylenie f_sample (sampling rate) z data logging interval (moÅ¼e byÄ‡ rÃ³Å¼ne: sample @ 1 kHz, log mean co 1 min)
- Stosowanie f_sample zbyt niskiego "Å¼eby oszczÄ™dziÄ‡ storage" â€“ NIGDY kosztem aliasing!

**Pytania studenckie**:
- Q: Dlaczego nie zawsze prÃ³bkowaÄ‡ z max. f_sample ADC (np. 100 kHz)?
- A: (1) Koszt storage/transmisji (100 kHz Ã— 24-bit Ã— 10 kanaÅ‚Ã³w = 2.4 MB/s), (2) CPU load (przetwarzanie FFT), (3) Power consumption (w IoT battery-powered). Wybierz f_sample adekwatnÄ… do f_max sygnaÅ‚u.

- Q: Czy moÅ¼na uÅ¼yÄ‡ filtru cyfrowego zamiast analogowego przed ADC?
- A: NIE do anti-aliasing! Cyfrowy dziaÅ‚a PO sampling â†’ aliasing juÅ¼ wystÄ…piÅ‚. Ale: cyfrowy MOÅ»E byÄ‡ dodatkowy (post-processing) dla dalszej redukcji szumu.

</InstructorNotes>

</Slide>

<VisualSeparator type="technical" />

<Slide title="ğŸ” Filtr anti-aliasing â€“ projektowanie i implementacja" type="tip">

<KeyConcept title="Dlaczego potrzebujemy filtru przed ADC?">

**Problem:** SygnaÅ‚ real-world zawiera:
- SygnaÅ‚ uÅ¼yteczny (f < f_max)
- Szumy (f > f_max): EMI, RF interference, harmonics

Bez filtru â†’ szumy >f_Nyquist **siÄ™ aliasujÄ…** i pojawiajÄ… w paÅ›mie sygnaÅ‚u â†’ nie do usuniÄ™cia!

**RozwiÄ…zanie:** Filtr dolnoprzepustowy (low-pass) PRZED ADC:

$$
f_{cutoff} = \frac{f_{sample}}{2 \times OSR} = \frac{f_{sample}}{2.5 - 5}
$$

**PrzykÅ‚ad:**
- f_sample = 10 kHz (wybrane dla systemu akwizycji)
- OSR = 2.5Ã— (standard)
- f_cutoff = 10000 / 2.5 = **4 kHz**

</KeyConcept>

<SupportingDetails title="ğŸ“ DobÃ³r typu i rzÄ™du filtru">

### Typy filtrÃ³w (frequency response):

**1. Butterworth**
- **Charakterystyka**: Maximally flat passband (brak ripple), monotoniczny roll-off
- **Roll-off**: -20 dB/decade Ã— order (1st: -20, 2nd: -40, 4th: -80, 8th: -160 dB/dec)
- **Phase**: Nieliniowa (group delay varies)
- **Zastosowanie**: **Najbardziej popularny** â€“ dobry kompromis

**2. Chebyshev**
- **Charakterystyka**: Steeper roll-off niÅ¼ Butterworth, ALE ripple w passband (Â±0.5-3 dB)
- **Roll-off**: Szybszy (lepszy stop-band)
- **Wady**: Ripple znieksztaÅ‚ca sygnaÅ‚ â†’ rzadko w anti-aliasing
- **Zastosowanie**: Gdy potrzeba bardzo stromego roll-off i tolerujesz ripple

**3. Bessel**
- **Charakterystyka**: Najlepsza phase linearity (constant group delay)
- **Roll-off**: Wolniejszy niÅ¼ Butterworth
- **Zastosowanie**: Gdy phase response ma znaczenie (pulse, transient analysis)
- **W anti-aliasing**: Rzadko (wolny roll-off wymaga wyÅ¼szego order)

**4. Elliptic (Cauer)**
- **Charakterystyka**: Najstromiejszy roll-off, ALE ripple w passband I stopband
- **Zastosowanie**: Bardzo specjalistyczne (komunikacja)
- **W anti-aliasing**: Prawie nigdy (ripple problem)

---

### DobÃ³r rzÄ™du (order) filtru:

**Wymaganie:** Attenuation @ f_sample/2 (f_Nyquist) powinien byÄ‡ >60-80 dB

**Butterworth roll-off:**
- 1st order: -20 dB/decade
- 2nd order: -40 dB/decade
- 4th order: -80 dB/decade (**standard dla anti-aliasing**)
- 8th order: -160 dB/decade (bardzo stromy, ale drogi i trudny)

**PrzykÅ‚ad obliczenia:**

System: f_cutoff = 4 kHz, f_sample = 10 kHz, f_Nyquist = 5 kHz

Potrzebna attenuation @ 5 kHz (octave = 5/4 = 1.25):

- **2nd order Butterworth**: -40 dB/dec Ã— logâ‚â‚€(1.25) = -40 Ã— 0.097 = **-3.9 dB/octave** Ã— 0.32 octaves = **-12.5 dB** (NIEDOSTATECZNE!)
- **4th order Butterworth**: -80 dB/dec Ã— 0.32 octaves = **-25 dB** (LEPIEJ, ale wciÄ…Å¼ maÅ‚o)
- **6th order Butterworth**: -120 dB/dec Ã— 0.32 octaves = **-38 dB** (DOBRE âœ“)

**Wniosek**: Dla OSR = 2.5Ã—, potrzeba **min. 6th order** Butterworth. Dla OSR = 5Ã—, wystarczy **4th order**.

---

### Implementacja (aktywny vs. pasywny):

**Pasywny (RC, LC):**
- **Zalety**: Tani, prosty, brak zasilania
- **Wady**: Brak wzmocnienia, obciÄ…Å¼a source (loading), trudny dobÃ³r dla high-order
- **Zastosowanie**: Low-order (1st, 2nd), non-critical

**Aktywny (op-amp based):**
- **Zalety**: Wzmocnienie, high input impedance, Å‚atwy high-order (kaskada)
- **Wady**: Wymaga zasilania, noise, GBW op-amp limit
- **Topologie**: Sallen-Key, Multiple Feedback (MFB), State Variable
- **Zastosowanie**: **Standard dla anti-aliasing** (4th-8th order)

**Kaskada 2nd order stages:**

4th order = 2Ã— 2nd order Sallen-Key  
8th order = 4Ã— 2nd order Sallen-Key

KaÅ¼dy stage ma Q factor (resonance) â€“ dla Butterworth: Qâ‚, Qâ‚‚ z tablic

</SupportingDetails>

<Example title="Projektowanie filtru anti-aliasing dla systemu wibracji">

**Specyfikacja:**
- **Aplikacja**: Monitoring wibracji main bearing (turbina wiatrowa)
- **InteresujÄ…ce pasmo**: 10 Hz - 2 kHz (BPFO, BPFI, harmonics)
- **ADC**: NI 9234 (f_sample options: 1.6, 3.2, 6.4, 12.8, 25.6, 51.2 kHz)
- **Czujnik**: Akcelerometr IEPE, flat response 1 Hz - 10 kHz

### Krok 1: WybÃ³r f_sample

f_max = 2 kHz (gÃ³rna granica interesujÄ…cego pasma)  
f_Nyquist = 2 Ã— 2000 = 4 kHz (absolute minimum)  
f_sample (z zapasem OSR = 3Ã—) = 3 Ã— 2 Ã— 2000 = **12 kHz**

Z opcji ADC: 12.8 kHz jest najbliÅ¼sze â†’ **f_sample = 12.8 kHz** âœ“

### Krok 2: Obliczenie f_cutoff

OSR actual = 12800 / (2 Ã— 2000) = **3.2Ã—**

f_cutoff = 12800 / (2 Ã— 3.2) = **2000 Hz** (dokÅ‚adnie f_max â€“ w praktyce trochÄ™ wyÅ¼ej dla marginesu)

Wybieramy **f_cutoff = 2.5 kHz** (daje pasmo dla nieznanych harmonics + margines na tolerancje)

### Krok 3: DobÃ³r typu i rzÄ™du filtru

**Typ**: Butterworth (flat passband, dobry roll-off)

**RzÄ…d**: SprawdÅº attenuation @ f_Nyquist = 6.4 kHz:

Octave ratio = 6.4 / 2.5 = **2.56** (logâ‚‚(2.56) = 1.36 octaves)

- 4th order: -24 dB/octave Ã— 1.36 = **-32.6 dB** (akceptowalne)
- 6th order: -36 dB/octave Ã— 1.36 = **-49 dB** (bardzo dobre)

Wybieramy **4th order Butterworth** (kompromis koszt/performance).

### Krok 4: Implementacja (Sallen-Key kaskada)

**Stage 1 (2nd order):**
- Qâ‚ = 0.541 (z tablic Butterworth 4th order)
- f_c1 = 2.5 kHz
- R1 = R2 = 6.8 kÎ©
- C1 = C2 = 10 nF
- Op-amp: TL072 (GBW = 3 MHz >> 2.5 kHz, wystarczy)

**Stage 2 (2nd order):**
- Qâ‚‚ = 1.307 (z tablic)
- f_c2 = 2.5 kHz
- R3 = R4 = 6.8 kÎ©
- C3 = C4 = 10 nF
- Op-amp: TL072

**Koszt BOM**: ~5 EUR (2Ã— op-amp IC, 4Ã— rezystory, 4Ã— kondensatory ceramiczne, PCB)

### Krok 5: Weryfikacja (pomiar z network analyzer)

Wymierzone @ f = 6.4 kHz (f_Nyquist):
- Attenuation: **-34 dB** âœ“ (close to calculated -32.6 dB)
- Phase: -270Â° (expected for 4th order @ high freq)

Pasmo uÅ¼yteczne (passband -3 dB): DC - 2.7 kHz âœ“ (powyÅ¼ej 2.5 kHz design)

**PASS** â€“ filtr gotowy do produkcji!

### Krok 6: Test w systemie (anti-aliasing effectiveness)

**Before filter:**
- SygnaÅ‚ testowy: 8 kHz sinusoid (powyÅ¼ej f_Nyquist)
- ADC @ 12.8 kHz widzi: **alias @ |8 - 12.8| = 4.8 kHz** âŒ

**After filter:**
- 8 kHz sinusoid attenuated: -34 dB â†’ amplitude reduced 50Ã— (98% suppression)
- Alias @ 4.8 kHz: **-34 dB poniÅ¼ej sygnaÅ‚u uÅ¼ytecznego** â†’ neglectable âœ“

**Sukces!** System dziaÅ‚a poprawnie, brak artefaktÃ³w aliasing w analizie FFT.

</Example>

<InstructorNotes>

**Czas**: 18-20 min (to kompleksowa sekcja!)

**Przebieg**:
1. Dlaczego filtr przed ADC (3 min) â€“ wyjaÅ›nij problem szumÃ³w >f_Nyquist
2. Typy filtrÃ³w (4 min) â€“ Butterworth, Chebyshev, Bessel, porÃ³wnanie
3. DobÃ³r rzÄ™du (4 min) â€“ obliczenia attenuation dla rÃ³Å¼nych orders
4. Case study: Filtr dla wibracji (5 min) â€“ full design flow
5. Q&A (2 min)

**Punkty kluczowe**:
- **Butterworth = workhorse** anti-aliasing (95% aplikacji)
- **4th-6th order** to standard (8th to overkill dla wiÄ™kszoÅ›ci)
- OSR = 3-5Ã— pozwala na 4th order (OSR = 2Ã— wymaga 6th-8th)
- **Always verify z network analyzer** po zbudowaniu

**Demonstracja praktyczna**:
- Bode plot rÃ³Å¼nych orders (1st vs. 2nd vs. 4th) â€“ widaÄ‡ rÃ³Å¼nicÄ™ w roll-off
- Breadboard 4th order Butterworth + function generator + oscyloskop
- LTspice simulation (pokazuje -3 dB punkt, roll-off slope)

**MateriaÅ‚y pomocnicze**:
- TI FilterPro Desktop (free software) â€“ auto-design Butterworth/Chebyshev
- Analog Devices Filter Wizard (online tool)
- Butterworth Q factors table (dla rÃ³Å¼nych orders 2-10)
- Sallen-Key calculator (online: http://sim.okawa-denshi.jp/en/Fkeisan.htm)

**Typowe bÅ‚Ä™dy studenckie**:
- Stosowanie 1st order RC (20 dB/dec) jako anti-aliasing â€“ ZA WOLNY roll-off!
- Mylenie f_cutoff filtru (np. 2 kHz) z f_sample (np. 10 kHz) â€“ to rÃ³Å¼ne czÄ™stotliwoÅ›ci
- GBW op-amp za niski (np. 100 kHz dla f_c = 50 kHz) â†’ filtr nie dziaÅ‚a jak Butterworth (peaking)

**Pytania studenckie**:
- Q: Czy moÅ¼na stosowaÄ‡ switched-capacitor filters zamiast aktywnych RC?
- A: TAK (np. MAX7400 series). Zalety: No external components, easy f_cutoff tuning (clock frequency). Wady: Clock noise, limited f_cutoff (max ~100 kHz). W anti-aliasing: OK dla f_c &lt;50 kHz.

- Q: Dlaczego Butterworth, a nie Chebyshev (steeper roll-off)?
- A: Chebyshev ma ripple w passband (Â±1-3 dB) â†’ znieksztaÅ‚ca sygnaÅ‚. W precision measurement: inacceptable. Butterworth = flat Â±0.1 dB â†’ preferred.

</InstructorNotes>

</Slide>

<VisualSeparator type="default" />

<Slide title="âš™ï¸ Parametryzacja strumieni danych â€“ praktyczne strategie" type="success">

<KeyPoints title="ğŸ“‹ Adaptive sampling strategies">

### **Fixed-rate sampling (klasyczne)**

StaÅ‚a f_sample przez caÅ‚y czas:
- **Zalety**: Prosty, przewidywalny data rate, Å‚atwy w analizie (FFT)
- **Wady**: Waste bandwidth w okresach "spokoju" (low dynamics)

**Zastosowanie**: 
- Continuous monitoring (CMS wibracji)
- Real-time control loops
- Gdy storage/bandwidth nie jest problemem

---

### **Triggered sampling (event-based)**

PrÃ³bkowanie tylko gdy trigger condition speÅ‚niony:
- **Trigger**: Threshold crossing, slope, pattern matching
- **Pre-trigger buffer**: Zapisz N prÃ³bek PRZED triggerem (circular buffer)
- **Post-trigger**: Kontynuuj M prÃ³bek PO triggerze

**PrzykÅ‚ad:**
- Wibracje: Trigger @ acceleration >2 g (spike detection)
- Record: 100 ms pre-trigger + 500 ms post-trigger @ 25 kHz
- **Data reduction**: 95% (triggeruje 5% czasu)

**Zastosowanie**:
- Transient events (shocks, impacts, electrical faults)
- Anomaly detection

---

### **Multi-rate sampling (hierarchical)**

RÃ³Å¼ne f_sample dla rÃ³Å¼nych kanaÅ‚Ã³w/pasm:
- **Slow channels**: Temp, pressure @ 1-10 Hz
- **Medium channels**: Voltage, current @ 100-1000 Hz
- **Fast channels**: Vibration @ 10-50 kHz

**Synchronizacja**: Common time base (GPS, PTP), different decimation ratios

**Data reduction**: 10-100Ã— vs. sampling everything @ max rate

**Zastosowanie**:
- Multi-sensor systems (SCADA)
- Mixed slow/fast dynamics

---

### **Adaptive sampling (intelligent)**

f_sample dynamicznie dostosowuje siÄ™ do dynamics sygnaÅ‚u:
- **High dynamics** (rapid changes) â†’ increase f_sample
- **Low dynamics** (steady state) â†’ decrease f_sample
- **Algorithm**: Slope detection, variance, autocorrelation

**PrzykÅ‚ad:**
- Baselinebaseline: 100 Hz
- Detect rapid change (slope >threshold) â†’ boost to 1 kHz for 10 s
- Return to baseline

**Data reduction**: 50-90% vs. fixed high rate

**Zastosowanie**:
- IoT (battery-powered)
- Cloud transmission (minimize bandwidth)

---

### **Compressed sensing (advanced)**

Sample at sub-Nyquist rate, reconstruct with sparsity algorithms:
- **Theory**: JeÅ›li sygnaÅ‚ jest "sparse" w jakiejÅ› domenie (time, frequency, wavelet), moÅ¼na sample &lt;f_Nyquist
- **Reconstruction**: L1-minimization, matching pursuit

**Zastosowanie**: Very niche (research), NIE dla general-purpose monitoring

</KeyPoints>

<SupportingDetails title="ğŸ“Š Tabela parametrÃ³w dla typowych strumieni OZE">

| StrumieÅ„ danych | Dynamics | f_sample | Data rate (1 kanal, 16-bit) | Agregacja typical | Retention |
|-----------------|----------|----------|------------------------------|-------------------|-----------|
| **PV string (I, V)** | Wolne (cloud trans.) | 10-100 Hz | 1.2-12 KB/s | 1-min mean | 10 lat (raw: 3 miesiÄ…ce) |
| **Pyranometer (G_POA)** | Wolne | 1-10 Hz | 0.12-1.2 KB/s | 1-min mean | 10 lat |
| **Temp (PT1000)** | Bardzo wolne | 0.1-1 Hz | 0.012-0.12 KB/s | 5-min mean | 10 lat |
| **Wind speed/dir** | Åšrednie | 1-10 Hz | 0.12-1.2 KB/s | 10-min mean/max/gust | 10 lat |
| **Vibration (low)** | Dynamiczne | 1-5 kHz | 12-60 KB/s | 10-min RMS, peak, kurtosis | 1 rok (raw: 1 mies.) |
| **Vibration (high)** | Bardzo dynamiczne | 25-50 kHz | 300-600 KB/s | On-demand (triggered) | 1 mies. (raw: 1 tydzieÅ„) |
| **Gas sensors (Hâ‚‚S)** | Wolne | 0.1-1 Hz | 0.012-0.12 KB/s | 1-min mean | 5 lat |
| **SCADA trends** | Wolne | 0.01-0.1 Hz | 0.001-0.012 KB/s | Pre-aggregated | 20 lat |
| **Electrical events (SOE)** | Impulsowe | Triggered @ kHz | Variable (events only) | Event log | 10 lat |

**Obserwacje:**
- **Slow processes** (temp, gaz): &lt;1 Hz â†’ data rate neglectable (&lt;1 MB/day)
- **Fast processes** (vibration high-freq): 50 kHz â†’ data rate massive (>50 GB/day) â†’ triggered sampling MUST
- **Aggregation** redukuje long-term storage 100-1000Ã— (rawâ†’mean)

</SupportingDetails>

<Example title="Optymalizacja strategii sampling â€“ farma wiatrowa 100 MW">

**Kontekst: 50 turbin Ã— 2 MW, kaÅ¼da ma CMS (Condition Monitoring System)**

### Wyzwanie:

**Naive approach (continuous high-rate):**
- KaÅ¼da turbina: 10 kanaÅ‚Ã³w wibracji @ 25 kHz Ã— 16-bit
- Data rate PER turbina: 10 Ã— 25000 Ã— 2 bytes = **500 KB/s** = 43 GB/day
- **CaÅ‚oÅ›Ä‡ farmy**: 50 Ã— 43 GB = **2150 GB/day** = 2.1 TB/day
- **MiesiÄ™cznie**: 63 TB
- **Rocznie**: 760 TB

**Koszt storage (cloud):**
- AWS S3: $0.023/GB/month (standard)
- 63 TB/month Ã— $23/TB = **$1450/month** = **$17 400/year** TYLKO storage (!)
- Plus: Upload bandwidth (egress), CPU processing

**NIE DO PRZYJÄ˜CIA** â€“ zbyt kosztowne.

---

### Optymalizacja (multi-tier strategy):

**Tier 1: Continuous low-rate (diagnostic features)**
- Frequency: 1 Hz (decimated z 25 kHz przez RMS/peak/kurtosis calculation @ edge)
- Features per kanaÅ‚: RMS, peak, kurtosis, crest factor (4Ã— values)
- Data rate PER turbina: 10 kanaÅ‚Ã³w Ã— 4 features Ã— 1 Hz Ã— 4 bytes (float32) = **160 bytes/s** = 13.8 MB/day
- **CaÅ‚oÅ›Ä‡ farmy**: 50 Ã— 13.8 MB = **690 MB/day**

**Tier 2: Triggered high-rate (event capture)**
- Trigger condition: RMS spike >3Ïƒ (standard deviation), OR kurtosis >4 (impulsive)
- Capture: 10 s @ 25 kHz (pre-trigger 1 s + post-trigger 9 s)
- Frequency: ~1-5 events/day per turbina (depends on health)
- Data per event: 10 s Ã— 25 kHz Ã— 10 kanaÅ‚Ã³w Ã— 2 bytes = **5 MB**
- Data rate: 5 events/day Ã— 5 MB = **25 MB/day** per turbina
- **CaÅ‚oÅ›Ä‡ farmy**: 50 Ã— 25 MB = **1250 MB/day**

**Tier 3: Scheduled high-rate (periodic diagnostics)**
- Frequency: 1Ã— per tydzieÅ„ (weekly deep analysis)
- Duration: 60 s @ 25 kHz (full FFT analysis)
- Data per turbina: 60 s Ã— 25 kHz Ã— 10 Ã— 2 = **30 MB**
- **CaÅ‚oÅ›Ä‡ farmy per week**: 50 Ã— 30 MB = **1500 MB/week** = **214 MB/day** (averaged)

---

### Total data rate (optimized):

- Tier 1: 690 MB/day
- Tier 2: 1250 MB/day
- Tier 3: 214 MB/day
- **TOTAL**: **2154 MB/day** â‰ˆ **2.1 GB/day**

**Reduction factor**: 2150 GB â†’ 2.1 GB = **1000Ã— reduction!**

**Koszt storage (optimized):**
- 2.1 GB/day Ã— 30 = **63 GB/month**
- $0.023/GB Ã— 63 = **$1.45/month** = **$17/year**

**Savings: $17 400 â†’ $17 = 99.9% cost reduction** âœ“

---

### Architektura implementacji:

```mermaid
graph TB
    A[Akcelerometry<br/>10 kanaÅ‚Ã³w @ 25 kHz] --> B[Edge Processor<br/>Turbina gondola]
    
    B --> C{Processing}
    C -->|Tier 1: Continuous| D[RMS, peak, kurtosis<br/>@ 1 Hz]
    C -->|Tier 2: Triggered| E[Spike detection<br/>â†’ 10s buffer @ 25kHz]
    C -->|Tier 3: Scheduled| F[Weekly 60s<br/>@ 25kHz]
    
    D --> G[4G/LTE<br/>to cloud]
    E --> G
    F --> G
    
    G --> H[InfluxDB<br/>Time-series DB]
    H --> I[Grafana<br/>Dashboards + alerts]
    H --> J[ML Model<br/>Anomaly detection]
    
    style A fill:#ffeb99
    style B fill:#90ee90
    style H fill:#87ceeb
    style J fill:#ffb6c1
```

**Edge processing (in gondola):**
- Industrial PC (Raspberry Pi 4 or NVIDIA Jetson Nano)
- Software: Python + NumPy/SciPy (DSP)
- Power: 5-15 W (turbina ma power, no problem)

**Benefits:**
- **Bandwidth savings**: 1000Ã— reduction â†’ moÅ¼liwoÅ›Ä‡ 4G/LTE (nie potrzeba fiber)
- **Storage savings**: 99.9% reduction â†’ cloud affordable
- **Latency**: Edge detects anomalies w czasie rzeczywistym (ms), nie czeka na cloud
- **Privacy**: Raw data stays local (tylko features/events do cloud)

</Example>

<InstructorNotes>

**Czas**: 16-18 min

**Przebieg**:
1. PrzeglÄ…d strategii sampling (5 min) â€“ fixed, triggered, multi-rate, adaptive
2. Tabela parametrÃ³w OZE (3 min)
3. Case study optymalizacji farmy wiatrowej (6 min) â€“ pokazuje 1000Ã— reduction
4. Dyskusja: Jak studenci podeszliby do problemu? (2 min)
5. Q&A (2 min)

**Punkty kluczowe**:
- **Continuous high-rate = EXPENSIVE** (storage, bandwidth)
- **Edge processing** (extract features locally) radykalnie redukuje data rate
- **Triggered sampling** dla events (transients, anomalies) â€“ 90-99% reduction
- **Multi-tier** strategy balances: continuous monitoring + event capture + deep diagnostics

**Demonstracja praktyczna**:
- PokaÅ¼ dashboard Grafana z Tier 1 (RMS trends) + Tier 2 (triggered events)
- Obliczenia data rate na tablicy â€“ studenci zobaczÄ… skalÄ™ problemu
- Python script: DSP feature extraction (RMS, kurtosis, crest factor) â€“ live demo

**MateriaÅ‚y pomocnicze**:
- Industrial IoT data strategies (whitepaper: AWS, Azure)
- Edge computing for wind turbines (case study: GE Digital, Siemens)
- InfluxDB retention policies (documentation)
- Grafana + telegraf for edge data aggregation (tutorial)

**Typowe bÅ‚Ä™dy studenckie**:
- MyÅ›lenie, Å¼e "wiÄ™cej danych = lepiej" â€“ NO! Quality > quantity, context > raw
- Ignorowanie kosztÃ³w storage/bandwidth â€“ w cloud: $$$ per GB
- Brak aggregation strategy â€“ keeping raw data forever = bankruptcy

**Pytania studenckie**:
- Q: Czy moÅ¼na uÅ¼ywaÄ‡ compression (gzip, etc.) zamiast decimation?
- A: TAK, ale: (1) Compression ratio dla time-series ~2-5Ã— (nie 1000Ã—), (2) CPU cost (na edge: limited power), (3) Trzeba decompress przed analysis. Feature extraction + triggered sampling > compression alone.

- Q: Co jeÅ›li triggered sampling MISS critical event (miÄ™dzy triggers)?
- A: Risk mitigation: (1) Conservative thresholds (trigger wczeÅ›niej), (2) Redundancja (multiple trigger algorithms), (3) Periodic full-rate (Tier 3) catches slow-developing issues. W critical: Tier 1 continuous features + Tier 2 triggered â†’ catch 99%+ events.

</InstructorNotes>

</Slide>

<VisualSeparator type="default" />

<Slide title="ğŸ“ Quiz: PrÃ³bkowanie i anti-aliasing" type="info">

<InteractiveQuiz 
  questions={[
    {
      question: "SygnaÅ‚ ma maksymalnÄ… czÄ™stotliwoÅ›Ä‡ f_max = 5 kHz. Jaka jest minimalna czÄ™stotliwoÅ›Ä‡ prÃ³bkowania wedÅ‚ug Nyquista?",
      options: [
        "5 kHz (rÃ³wna f_max)",
        "10 kHz (2 Ã— f_max)",
        "12.5 kHz (2.5 Ã— f_max, practical)",
        "25 kHz (5 Ã— f_max, conservative)"
      ],
      correctAnswer: 1,
      explanation: "Twierdzenie Nyquista: f_sample â‰¥ 2 Ã— f_max. Dla f_max = 5 kHz â†’ f_Nyquist = 10 kHz (MINIMUM teoretyczne). W praktyce: 2.5-5Ã— (12.5-25 kHz), ale pytanie o Nyquist â†’ 10 kHz."
    },
    {
      question: "Mamy f_sample = 8 kHz. SygnaÅ‚ zakÅ‚Ã³cajÄ…cy ma czÄ™stotliwoÅ›Ä‡ 7 kHz (powyÅ¼ej f_Nyquist = 4 kHz). Jaka czÄ™stotliwoÅ›Ä‡ alias pojawi siÄ™ w ADC?",
      options: [
        "7 kHz (bez zmian)",
        "1 kHz (|7 - 8|)",
        "3 kHz (7 - 4)",
        "15 kHz (7 + 8)"
      ],
      correctAnswer: 1,
      explanation: "Alias: f_alias = |f_signal - nÃ—f_sample|. Dla n=1: |7 - 8| = 1 kHz. SygnaÅ‚ 7 kHz 'zawija siÄ™' i pojawia jako 1 kHz. Opcja (c) to bÅ‚Ä™dne odejmowanie f_Nyquist. Opcja (d) to suma (nie ma sensu)."
    },
    {
      question: "Projektujemy filtr anti-aliasing dla systemu z f_sample = 20 kHz. OSR (oversampling ratio) = 4Ã—. Jaka powinna byÄ‡ f_cutoff filtru?",
      options: [
        "10 kHz (f_sample/2, Nyquist)",
        "5 kHz (f_sample/4)",
        "2.5 kHz (f_sample/8 = f_sample/(2Ã—OSR))",
        "20 kHz (rÃ³wna f_sample)"
      ],
      correctAnswer: 2,
      explanation: "OSR = f_sample / (2 Ã— f_max) â†’ f_max = f_sample / (2 Ã— OSR). Dla OSR=4: f_max = 20000 / (2Ã—4) = 2500 Hz. f_cutoff â‰ˆ f_max. Alternatywnie: f_cutoff = f_sample / (2Ã—OSR) = 20000/8 = 2.5 kHz."
    },
    {
      question: "Filtr Butterworth 4th order ma roll-off -80 dB/decade. Po przesuniÄ™ciu o 1 octave (podwojenie czÄ™stotliwoÅ›ci) od f_cutoff, jaka jest attenuation?",
      options: [
        "-24 dB/octave Ã— 1 = -24 dB",
        "-80 dB (caÅ‚kowita dekada)",
        "-40 dB (poÅ‚owa dekady = octave)",
        "Nie moÅ¼na obliczyÄ‡ bez logarytmÃ³w"
      ],
      correctAnswer: 0,
      explanation: "-80 dB/decade = -24 dB/octave (bo decade = 10Ã—, octave = 2Ã—, logâ‚â‚€(2) â‰ˆ 0.3). 1 octave â†’ -24 dB. Opcja (c) mylÄ…co sugeruje -40 dB, ale to dla 2nd order. Opcja (d) nieprawda â€“ prosta konwersja: -80 dB/dec Ã· 3.32 â‰ˆ -24 dB/oct."
    },
    {
      question: "W farmie wiatrowej 100 MW (50 turbin) stosowano continuous sampling @ 25 kHz (2.1 TB/day). Po optymalizacji (edge processing + triggered + scheduled) data rate spadÅ‚ do 2.1 GB/day. Jaki jest reduction factor?",
      options: [
        "100Ã— (2100/21)",
        "1000Ã— (2100 GB / 2.1 GB)",
        "10Ã— (tylko jeden rzÄ…d wielkoÅ›ci)",
        "Nie moÅ¼na porÃ³wnaÄ‡ (rÃ³Å¼ne units)"
      ],
      correctAnswer: 1,
      explanation: "2.1 TB = 2100 GB. Reduction: 2100 GB / 2.1 GB = 1000Ã—. Opcja (a) bÅ‚Ä™dnie dzieli 2100/21 = 100 (brak konwersji TBâ†’GB). Opcja (d) nieprawda â€“ obie sÄ… w GB po konwersji."
    }
  ]}
/>

:::tip Rekomendacja po quizie
JeÅ›li uzyskaÅ‚eÅ› &lt;80% poprawnych odpowiedzi, przejrzyj sekcje o twierdzeniu Nyquista (f_sample â‰¥ 2Ã—f_max), obliczaniu aliasing (|f - nÃ—f_s|), i konwersji dB/decade â†” dB/octave. Zrozumienie tych fundamentÃ³w jest kluczowe dla projektowania systemÃ³w akwizycji.
:::

</Slide>

</SlideContainer>

---

## Podsumowanie i wnioski

**Kluczowe punkty z tej sekcji:**

1. **Twierdzenie Nyquista: f_sample â‰¥ 2 Ã— f_max** â€“ to MINIMUM teoretyczne. W praktyce: **2.5-5Ã— zapas** dla real-world filtrÃ³w.

2. **Aliasing to nieodwracalna strata** â€“ wysokie czÄ™stotliwoÅ›ci "zawijajÄ… siÄ™" jako faÅ‚szywe niskie. Po sampling NIE DA SIÄ˜ cofnÄ…Ä‡ â†’ filtr anty-aliasing PRZED ADC to must.

3. **Filtr Butterworth 4th order to standard** â€“ flat passband, -80 dB/decade roll-off. Dla OSR=3-5Ã— wystarczy 4th order. OSR=2Ã— wymaga 6th-8th order.

4. **Parametry sampling zaleÅ¼Ä… od dynamics sygnaÅ‚u:**
   - Slow (temp, gas): 0.1-1 Hz
   - Medium (PV strings): 10-100 Hz
   - Fast (vibration low-freq): 1-5 kHz
   - Very fast (vibration high-freq): 25-50 kHz

5. **Multi-tier sampling strategy** radykalnie redukuje data rate:
   - Tier 1: Continuous low-rate (features: RMS, kurtosis) @ 1 Hz
   - Tier 2: Triggered high-rate (events) @ 25 kHz, 1-5% czasu
   - Tier 3: Scheduled deep analysis @ 25 kHz, weekly
   - **Reduction: 100-1000Ã—** vs. continuous high-rate â†’ savings $$$ storage/bandwidth

6. **Edge processing to game-changer** â€“ extract features locally (DSP @ edge), send only relevant data to cloud. Raspberry Pi/Jetson moÅ¼e przetwarzaÄ‡ 10 kanaÅ‚Ã³w @ 25 kHz real-time.

**Typowe bÅ‚Ä™dy do unikania:**
- f_sample = 2Ã—f_max (Nyquist) w praktyce â€“ zawsze 2.5-5Ã— zapas!
- Brak filtru anty-aliasing ("filter cyfrowy po ADC wystarczy") â€“ aliasing juÅ¼ siÄ™ staÅ‚
- Continuous high-rate dla wszystkiego â€“ koszty storage/bandwidth eksplodujÄ…
- Ignorowanie edge processing â€“ wysyÅ‚anie raw data to waste bandwidth

**NastÄ™pne kroki:**
- Ä†wiczenie 8: Obliczanie f_sample, projektowanie filtru Butterworth (online calculator)
- Lab hands-on: Breadboard 4th order filter + test z function generator
- Przygotowanie do nastÄ™pnej sekcji: Synchronizacja czasu (NTP/PTP)

---

**Dodatkowe zasoby:**
- **Lyons**: "Understanding Digital Signal Processing" (bible of DSP)
- **TI**: "ADC Sampling Frequency Selection" (AN-282)
- **Analog Devices Filter Wizard**: Online tool (https://tools.analog.com/en/filterwizard/)
- **Python**: `scipy.signal` library â€“ Butterworth design, `lfilter()` simulation
- **LTspice**: Free circuit simulator â€“ design/test filters (https://www.analog.com/ltspice)
