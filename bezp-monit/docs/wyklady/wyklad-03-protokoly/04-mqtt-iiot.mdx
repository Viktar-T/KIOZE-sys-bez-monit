---
title: "MQTT publish-subscribe i IIoT"
sidebar_position: 4
---

import { 
  SlideContainer, 
  Slide, 
  KeyPoints, 
  SupportingDetails, 
  InstructorNotes,
  VisualSeparator,
  LearningObjective,
  KeyConcept,
  Example
} from '@site/src/components/SlideComponents';

<LearningObjective>
Po tej sekcji student potrafi:
- Wyja≈õniƒá podstawy protoko≈Çu MQTT (publish-subscribe model) i jego zalety w systemach IIoT
- Rozr√≥≈ºniƒá poziomy QoS (Quality of Service) w MQTT i zastosowaƒá odpowiedni w zale≈ºno≈õci od aplikacji
- Zaprojektowaƒá topologiƒô MQTT dla instalacji OZE z broker'ami, topic'ami i retained messages
- Zintegrowaƒá MQTT z systemami SCADA oraz innymi protoko≈Çami (Modbus, OPC UA)
</LearningObjective>

<SlideContainer>

<Slide title="üì° Wprowadzenie do MQTT" type="info">

<KeyPoints title="üìã Co to jest MQTT?">
- **MQTT** = Message Queuing Telemetry Transport
- **Protok√≥≈Ç publish-subscribe** - nadawca (publisher) i odbiorcy (subscribers)
- **Lekki i efektywny** - minimalny overhead, idealny dla urzƒÖdze≈Ñ IoT
- **Orientowany na sieci** - zaprojektowany dla niestabilnych po≈ÇƒÖcze≈Ñ
- **Platform agnostic** - dzia≈Ça na ka≈ºdym systemie z TCP/IP
- **Standard OASIS** - otwarty standard komunikacji
</KeyPoints>

<SupportingDetails title="üéØ Dlaczego MQTT w systemach OZE?">

**Zalety MQTT wzglƒôdem tradycyjnych protoko≈Ç√≥w:**

**1. Decoupling** - nadawca nie musi znaƒá odbiorc√≥w
- Jeden czujnik mo≈ºe wysy≈Çaƒá dane do wielu system√≥w jednocze≈õnie
- ≈Åatwe dodawanie nowych odbiorc√≥w bez modyfikacji nadawcy

**2. Resilience** - dzia≈Ça w niestabilnych sieciach
- **Last Will Testament** - powiadomienia o roz≈ÇƒÖczeniu urzƒÖdzenia
- **Retained messages** - nowi subscribers otrzymujƒÖ ostatnie dane
- **Automatic reconnection** - odbudowa po≈ÇƒÖczenia po przerwie

**3. Scalability** - ≈Çatwe rozszerzanie systemu
- **Topic hierarchy** - organizacja wiadomo≈õci w strukturze drzewa
- **Broker clustering** - skalowanie poprzez wiele broker√≥w

</SupportingDetails>

**Architektura MQTT w systemie OZE:**

```mermaid
graph TB
    subgraph "MQTT Broker"
        BROKER[MQTT Broker<br/>mosquitto/eclipse]
        SUB1[Topic: pv/inverter/01/power]
        SUB2[Topic: pv/weather/irradiance]
        SUB3[Topic: bess/battery/soc]
    end
    
    subgraph "Publishers (Sensors/Devices)"
        PLC1[PLC Inverter 01]
        PLC2[PLC Weather Station]
        PLC3[PLC BESS]
        
        PLC1 -->|publish| SUB1
        PLC2 -->|publish| SUB2
        PLC3 -->|publish| SUB3
    end
    
    subgraph "Subscribers (SCADA/Cloud)"
        SCADA[SCADA Server]
        CLOUD[Cloud Platform]
        HMI[HMI Display]
        
        SUB1 -->|subscribe| SCADA
        SUB2 -->|subscribe| SCADA
        SUB3 -->|subscribe| SCADA
        
        SUB1 -->|subscribe| CLOUD
        SUB2 -->|subscribe| CLOUD
        SUB3 -->|subscribe| CLOUD
        
        SUB1 -->|subscribe| HMI
        SUB2 -->|subscribe| HMI
    end
    
    style BROKER fill:#ffd700
    style PLC1 fill:#87ceeb
    style SCADA fill:#90ee90
    style CLOUD fill:#ffb6c1
```

<InstructorNotes>

**MQTT to rewolucja** w komunikacji przemys≈Çowej - szczeg√≥lnie w kontek≈õcie IoT i edge computing.

**Kluczowa r√≥≈ºnica**: **publish-subscribe vs request-response**. W Modbus/OPC UA to "pytanie-odpowied≈∫". W MQTT urzƒÖdzenie **publikuje dane spontanicznie**, a **odbiorcy subskrybujƒÖ to co ich interesuje**.

**Decoupling** - to ogromna zaleta. Czujnik prƒÖdu publikuje do `pv/inverter/01/power`, a **jednocze≈õnie** SCADA, cloud platform i HMI mogƒÖ subskrybowaƒá te same dane. **Nie trzeba modyfikowaƒá czujnika** gdy dodajesz nowego odbiorcƒô.

Poka≈º diagram - **Broker to centralny hub**, **Publishers** wysy≈ÇajƒÖ dane, **Subscribers** je odbierajƒÖ. **Topic hierarchy** - `pv/inverter/01/power` to struktura drzewa ≈Çatwa do nawigacji.

**Resilience** - to kluczowe w OZE gdzie czƒôsto mamy **unstable network connections** (remote sites, cellular, satellite).

**Czas**: 6-7 minut z diagramem architektury.

</InstructorNotes>

</Slide>

<VisualSeparator type="default" />

<Slide title="üè∑Ô∏è Topic Structure i Message Format" type="tip">

<KeyPoints title="üìã Hierarchiczna struktura topic√≥w">
- **Topic** = nazwa/kategoria dla wiadomo≈õci (jak adres pocztowy)
- **Hierarchical structure** - u≈ºywa separatora "/" jak ≈õcie≈ºka w systemie plik√≥w
- **Wildcards** - "+" (single level) i "#" (multi-level) do subskrypcji grup
- **Naming convention** - sp√≥jne nazewnictwo dla ca≈Çej instalacji
</KeyPoints>

**Topic hierarchy dla farmy PV+BESS:**

```mermaid
graph TB
    subgraph "Topic Structure Example"
        ROOT[/pv-farm/]
        
        subgraph "Inverters Topics"
            INV[/pv-farm/inverters/]
            INV01[/pv-farm/inverters/01/]
            INV02[/pv-farm/inverters/02/]
            
            INV01_PWR[/pv-farm/inverters/01/power]
            INV01_VOLT[/pv-farm/inverters/01/voltage]
            INV01_TEMP[/pv-farm/inverters/01/temperature]
            INV01_STAT[/pv-farm/inverters/01/status]
            
            INV01 --- INV01_PWR
            INV01 --- INV01_VOLT
            INV01 --- INV01_TEMP
            INV01 --- INV01_STAT
        end
        
        subgraph "Weather Topics"
            WTHR[/pv-farm/weather/]
            IRR[/pv-farm/weather/irradiance]
            TEMP[/pv-farm/weather/temperature]
            WIND[/pv-farm/weather/wind-speed]
            
            WTHR --- IRR
            WTHR --- TEMP
            WTHR --- WIND
        end
        
        subgraph "BESS Topics"
            BESS[/pv-farm/bess/]
            SOC[/pv-farm/bess/soc]
            POWER[/pv-farm/bess/power]
            VOLTAGE[/pv-farm/bess/voltage]
            
            BESS --- SOC
            BESS --- POWER
            BESS --- VOLTAGE
        end
        
        ROOT --- INV
        ROOT --- WTHR
        ROOT --- BESS
        INV --- INV01
        INV --- INV02
    end
    
    style ROOT fill:#ffd700
    style INV fill:#87ceeb
    style WTHR fill:#90ee90
    style BESS fill:#ffb6c1
```

<Example title="Przyk≈Çadowe messages w systemie PV">

**Format wiadomo≈õci:**
```
Topic: /pv-farm/inverters/01/power
Message: {"value": 15500, "unit": "W", "timestamp": "2024-01-15T10:30:45Z", "quality": "good"}

Topic: /pv-farm/weather/irradiance  
Message: {"value": 850, "unit": "W/m¬≤", "timestamp": "2024-01-15T10:30:45Z"}

Topic: /pv-farm/bess/soc
Message: {"value": 65.2, "unit": "%", "timestamp": "2024-01-15T10:30:45Z"}
```

**Subscriptions z wildcards:**
```
Subscribe to: /pv-farm/inverters/+/power    # Wszystkie inwertery, tylko power
Subscribe to: /pv-farm/inverters/01/#       # Wszystkie dane z inwertera 01
Subscribe to: /pv-farm/#                    # Wszystkie dane z ca≈Çej farmy
```

</Example>

<KeyConcept title="üîç Best Practices dla naming convention">

**1. Hierarchical naming**
- `/company/facility/device/measurement`
- `/pv-farm/inverters/01/power`

**2. Consistent units**
- Wszystkie warto≈õci w standardowych jednostkach SI
- Explicit unit field w JSON payload

**3. Structured payload**
- JSON format z timestamp, value, quality, unit
- Versioning dla schema evolution

**4. Topic levels**
- Nie wiƒôcej ni≈º 5-6 poziom√≥w (performance)
- Logiczne grupowanie wed≈Çug funkcjonalno≈õci

</KeyConcept>

<InstructorNotes>

**Topic structure to foundation** MQTT system - musi byƒá przemy≈õlany z g√≥ry.

**Naming convention** - poka≈º przyk≈Çad z farmy PV. **Hierarchical** structure: facility ‚Üí category ‚Üí device ‚Üí measurement. To u≈Çatwia **wildcard subscriptions** i **maintenance**.

**Wildcards** - **"+"** to single level (wszystkie inwertery), **"#"** to multi-level (wszystko z inwertera 01). To bardzo powerful feature do **bulk subscriptions**.

**Message format** - **JSON** to standard, ale wa≈ºne sƒÖ **consistency** i **schema**. **Timestamp**, **quality flags**, **units** - to metadata potrzebne w systemach przemys≈Çowych.

**Best practices** - nie wiƒôcej ni≈º 5-6 poziom√≥w topic (performance impact), **logical grouping**, **SI units**.

**Poka≈º praktyczne przyk≈Çady**: jak subscribe do wszystkich inverter power values, jak dodaƒá nowy device bez zmiany existing code.

**Czas**: 6-7 minut z praktycznymi przyk≈Çadami subscriptions.

</InstructorNotes>

</Slide>

<VisualSeparator type="default" />

<Slide title="‚öôÔ∏è QoS Levels - Quality of Service" type="technical">

<KeyPoints title="üìã Poziomy QoS w MQTT">
- **QoS 0** - "At most once" - fire and forget, mo≈ºe byƒá zgubiona
- **QoS 1** - "At least once" - gwarantuje delivery, mo≈ºe byƒá duplikat
- **QoS 2** - "Exactly once" - gwarantuje delivery bez duplikat√≥w, ale wiƒôkszy overhead
- **Wyb√≥r QoS** zale≈ºy od typu danych i wymaga≈Ñ aplikacji
</KeyPoints>

**Por√≥wnanie poziom√≥w QoS:**

| Kryterium | QoS 0 | QoS 1 | QoS 2 |
|-----------|-------|-------|-------|
| **Delivery guarantee** | Nie | Tak | Tak |
| **Duplicates** | Nie | Mo≈ºliwe | Nie |
| **Network overhead** | Minimalny | ≈öredni | Wysoki |
| **Latency** | Najni≈ºszy | ≈öredni | Najwy≈ºszy |
| **Use cases** | Telemetry | Commands | Critical data |

**Architektura QoS:**

```mermaid
sequenceDiagram
    participant Publisher
    participant Broker
    participant Subscriber
    
    Note over Publisher,Subscriber: QoS 0 - Fire and Forget
    Publisher->>Broker: PUBLISH (QoS 0)
    Broker->>Subscriber: FORWARD
    Note over Subscriber: Message mo≈ºe byƒá lost
    
    Note over Publisher,Subscriber: QoS 1 - At Least Once
    Publisher->>Broker: PUBLISH (QoS 1)
    Broker-->>Publisher: PUBACK
    Broker->>Subscriber: PUBLISH (QoS 1)
    Subscriber-->>Broker: PUBACK
    Note over Subscriber: Gwarantowana delivery,<br/>mo≈ºliwy duplicate
    
    Note over Publisher,Subscriber: QoS 2 - Exactly Once
    Publisher->>Broker: PUBLISH (QoS 2)
    Broker-->>Publisher: PUBREC
    Publisher-->>Broker: PUBREL
    Broker-->>Publisher: PUBCOMP
    Broker->>Subscriber: PUBLISH (QoS 2)
    Subscriber-->>Broker: PUBREC
    Broker-->>Subscriber: PUBREL
    Subscriber-->>Broker: PUBCOMP
    Note over Subscriber: Exactly once delivery
```

<Example title="Dob√≥r QoS dla r√≥≈ºnych typ√≥w danych OZE">

**QoS 0 - Telemetry data (czƒôste, niekrytyczne):**
```
Topic: /pv-farm/inverters/01/temperature
Reason: Wysoka czƒôstotliwo≈õƒá (co 10s), utrata kilku samples nie krytyczna
Performance: Minimal overhead dla high-frequency data
```

**QoS 1 - Commands i alarms:**
```
Topic: /pv-farm/inverters/01/commands/start
Reason: Komendy muszƒÖ dotrzeƒá, duplikat nie szkodzi
Performance: Balance miƒôdzy reliability i overhead
```

**QoS 2 - Critical data (rozliczenia, status):**
```
Topic: /pv-farm/bess/battery/soc
Reason: SOC (State of Charge) critical dla safety, no duplicates allowed
Performance: Highest reliability, acceptable overhead dla critical data
```

</Example>

<SupportingDetails title="‚ö†Ô∏è Considerations dla wyboru QoS">

**Network conditions:**
- **Stable networks**: QoS 0 dla telemetry mo≈ºe wystarczyƒá
- **Unstable networks**: QoS 1 minimum dla important data
- **Satellite/cellular**: QoS 1 dla commands, QoS 0 dla telemetry

**Performance impact:**
- **QoS 0**: ~100x more messages/second mo≈ºliwe
- **QoS 1**: ~10x overhead vs QoS 0
- **QoS 2**: ~3x overhead vs QoS 1

**Application requirements:**
- **Real-time dashboards**: QoS 0 acceptable
- **Control commands**: QoS 1 minimum
- **Financial data**: QoS 2 recommended

</SupportingDetails>

<InstructorNotes>

**QoS levels to fundamental concept** MQTT - trzeba rozumieƒá trade-offs.

**QoS 0** - **fire and forget**, najszybszy ale **no guarantee**. **Good for high-frequency telemetry** gdzie utrata kilku samples nie jest krytyczna.

**QoS 1** - **at least once delivery** - **standard choice** dla wiƒôkszo≈õci industrial applications. **Overhead acceptable**, **duplicates manageable** w aplikacji.

**QoS 2** - **exactly once** - **highest reliability** ale **significant overhead**. **Only for critical data** gdzie duplicates sƒÖ unacceptable.

Poka≈º **sequence diagram** - to pomaga zrozumieƒá **message flow** i **overhead** ka≈ºdego poziomu.

**Practical recommendation**:
- **Telemetry** (temperature, power): QoS 0
- **Commands** (start/stop): QoS 1  
- **Critical status** (SOC, safety): QoS 2

**Network conditions matter** - w **unstable networks** (cellular, satellite) **QoS 1 minimum** nawet dla telemetry.

**Czas**: 7-8 minut z praktycznymi przyk≈Çadami doboru QoS.

</InstructorNotes>

</Slide>

<VisualSeparator type="default" />

<Slide title="üîÑ MQTT Broker - konfiguracja i zarzƒÖdzanie" type="info">

<KeyPoints title="üìã Popularne MQTT Brokers">
- **Eclipse Mosquitto** - open source, lekki, idealny do embedded
- **HiveMQ** - commercial, enterprise-grade, clustering support
- **EMQX** - scalable, high-performance, edge computing
- **AWS IoT Core** - managed service, integracja z chmurƒÖ
- **Azure IoT Hub** - Microsoft managed service
</KeyPoints>

**Architektura MQTT Broker:**

```mermaid
graph TB
    subgraph "MQTT Broker Cluster"
        LB[Load Balancer<br/>HAProxy/nginx]
        
        subgraph "Broker Nodes"
            B1[MQTT Broker 1<br/>mosquitto]
            B2[MQTT Broker 2<br/>mosquitto]
            B3[MQTT Broker 3<br/>mosquitto]
            
            B1 --- B2
            B2 --- B3
            B3 --- B1
        end
        
        subgraph "Data Storage"
            DB[(InfluxDB<br/>Time Series)]
            REDIS[(Redis<br/>Retained Messages)]
        end
        
        subgraph "Security & Auth"
            AUTH[Authentication<br/>File/JWT/Database]
            ACL[Access Control<br/>Topic Permissions]
        end
        
        LB --- B1
        LB --- B2
        LB --- B3
        
        B1 --- DB
        B2 --- REDIS
        B3 --- AUTH
        B3 --- ACL
    end
    
    subgraph "Clients"
        PLC[PLC Devices]
        SCADA[SCADA Systems]
        CLOUD[Cloud Platforms]
        
        PLC --- LB
        SCADA --- LB
        CLOUD --- LB
    end
    
    style LB fill:#ffd700
    style B1 fill:#87ceeb
    style B2 fill:#87ceeb
    style B3 fill:#87ceeb
```

<Example title="Podstawowa konfiguracja Mosquitto">

**mosquitto.conf:**
```conf
# Basic listening configuration
listener 1883 0.0.0.0
listener 8883 0.0.0.0
cafile /path/to/ca.crt
certfile /path/to/server.crt
keyfile /path/to/server.key

# Persistence and logging
persistence true
persistence_location /var/lib/mosquitto/
log_dest file /var/log/mosquitto/mosquitto.log

# Connection limits
max_connections -1
max_inflight_messages 20

# Retained messages
max_retained_messages 1000

# Authentication
allow_anonymous false
password_file /etc/mosquitto/passwd
acl_file /etc/mosquitto/acl.conf
```

**ACL (Access Control List):**
```conf
# User permissions
user pv_operator
topic read pv-farm/inverters/+/+
topic write pv-farm/inverters/+/commands/+

user weather_sensor
topic write pv-farm/weather/+

user scada_system
topic readwrite pv-farm/#
```

</Example>

<SupportingDetails title="üéØ Key Features dla Industrial IoT">

**1. Retained Messages**
- Broker przechowuje ostatniƒÖ wiadomo≈õƒá dla ka≈ºdego topic
- Nowi subscribers automatycznie otrzymujƒÖ current state
- Essential dla status monitoring w OZE

**2. Last Will Testament (LWT)**
- Broker publikuje wiadomo≈õƒá gdy client disconnect
- Idealny do wykrywania awarii urzƒÖdze≈Ñ
- Topic: `/device/pv-inverter-01/status` payload: `{"online": false}`

**3. Keep Alive/Ping**
- Client regular heartbeat do broker
- Wykrywa "silent deaths" w network
- Typowo 60 seconds keep_alive interval

**4. Message Persistence**
- QoS 1/2 messages stored podczas reconnection
- Nie traci danych podczas brief network outages

</SupportingDetails>

<InstructorNotes>

**MQTT Broker to brain** ca≈Çego systemu - wyb√≥r i konfiguracja majƒÖ ogromny wp≈Çyw na performance i reliability.

**Eclipse Mosquitto** - **most popular open source** broker, idealny do startu i **small-medium deployments**. **Lightweight**, ≈Çatwa konfiguracja.

**Commercial solutions** (HiveMQ, EMQX) dla **larger deployments** - **clustering**, **load balancing**, **enterprise support**.

Poka≈º **cluster architecture** - **load balancer**, **multiple broker nodes**, **shared storage**. To dla **high availability** i **scalability**.

**Configuration example** - **mosquitto.conf** pokazuje **key settings**:
- **Security** (TLS, authentication)
- **Persistence** (data retention)
- **ACL** (access control)

**ACL example** - to **critical for security** w industrial systems. **Role-based access** - sensors can write, operators can read, SCADA can read/write.

**Key features**:
- **Retained messages** - **essential** dla OZE monitoring (last known state)
- **LWT** - **ideal** dla **device health monitoring**
- **Keep alive** - **network health** detection

**Czas**: 7-8 minut z praktycznymi przyk≈Çadami konfiguracji.

</InstructorNotes>

</Slide>

<VisualSeparator type="success" />

<Slide title="üîó Integracja MQTT z systemami SCADA" type="success">

<KeyPoints title="üìã Typowe scenariusze integracji">
- **Modbus ‚Üí MQTT Bridge** - PLC zbiera dane Modbus, publikuje MQTT
- **OPC UA ‚Üí MQTT Gateway** - OPC UA data convertowane do MQTT messages
- **MQTT ‚Üí SCADA** - SCADA systems jako MQTT subscribers
- **Cloud Integration** - MQTT messages forwarded do cloud platforms
</KeyPoints>

**Architektura integracji:**

```mermaid
graph TB
    subgraph "Field Level"
        PLC1[PLC Inverter 1<br/>Modbus Master]
        PLC2[PLC Weather<br/>Modbus Master]
        INVERTER[Inwerter<br/>Modbus Slave]
        WEATHER[Stacja pogodowa<br/>Modbus Slave]
        
        PLC1 ---|Modbus RTU| INVERTER
        PLC2 ---|Modbus RTU| WEATHER
    end
    
    subgraph "Gateway Layer"
        GW1[Gateway 1<br/>Modbus‚ÜíMQTT]
        GW2[Gateway 2<br/>Modbus‚ÜíMQTT]
        
        PLC1 ---|Ethernet| GW1
        PLC2 ---|Ethernet| GW2
    end
    
    subgraph "Communication Layer"
        BROKER[MQTT Broker<br/>Clustered]
        
        GW1 -->|MQTT Publish| BROKER
        GW2 -->|MQTT Publish| BROKER
    end
    
    subgraph "Application Layer"
        SCADA[SCADA Server<br/>MQTT Subscriber]
        HIST[Historical DB<br/>InfluxDB]
        CLOUD[Cloud Platform<br/>AWS IoT]
        
        BROKER -->|MQTT Subscribe| SCADA
        BROKER -->|MQTT Subscribe| HIST
        BROKER -->|MQTT Subscribe| CLOUD
    end
    
    style GW1 fill:#ffd700
    style GW2 fill:#ffd700
    style BROKER fill:#87ceeb
    style SCADA fill:#90ee90
```

<Example title="Node-RED jako Modbus‚ÜíMQTT Bridge">

**Node-RED flow example:**
```javascript
// Modbus read ‚Üí MQTT publish flow
[{"id":"modbus-read","type":"modbus-read","z":"flow1"},
 {"id":"format-data","type":"function","z":"flow1","func":"msg.payload = {\n    value: msg.payload.data[0],\n    unit: 'W',\n    timestamp: new Date().toISOString(),\n    device: 'inverter-01'\n};\nmsg.topic = '/pv-farm/inverters/01/power';\nreturn msg;"},
 {"id":"mqtt-publish","type":"mqtt out","z":"flow1","topic":"","qos":"1","retain":"false","broker":"broker-config"}]
```

**SCADA subscriber example (Python):**
```python
import paho.mqtt.client as mqtt
import json

def on_message(client, userdata, message):
    data = json.loads(message.payload.decode())
    topic = message.topic
    
    # Parse topic: /pv-farm/inverters/01/power
    parts = topic.split('/')
    facility = parts[1]  # pv-farm
    category = parts[2]  # inverters
    device = parts[3]    # 01
    measurement = parts[4] # power
    
    # Update SCADA database
    update_scada_database(facility, category, device, measurement, data)

client = mqtt.Client()
client.on_message = on_message
client.connect("mqtt-broker", 1883, 60)

# Subscribe to all inverter data
client.subscribe("/pv-farm/inverters/+/+")
client.loop_forever()
```

</Example>

<KeyConcept title="üéØ Advantages MQTT integration">

**1. Protocol Bridging**
- **Legacy systems** (Modbus, DNP3) mogƒÖ komunikowaƒá siƒô z **modern systems**
- **Incremental modernization** - nie trzeba wymieniaƒá wszystkiego naraz

**2. Data Distribution**
- **One source, many consumers** - jeden czujnik, wiele aplikacji
- **Real-time** updates dla wszystkich interested parties

**3. Network Resilience**
- **Automatic reconnection** po network failures
- **Message persistence** dla reliable delivery

**4. Cloud Integration**
- **Direct connection** do cloud platforms (AWS IoT, Azure IoT Hub)
- **Hybrid architectures** (on-premise + cloud)

</KeyConcept>

<InstructorNotes>

**Integration scenarios** to **real-world application** MQTT w industrial systems.

**Bridge architecture** - **Gateways** (Node-RED, custom solutions) **convert** Modbus/OPC UA data do MQTT format. **Multiple consumers** (SCADA, cloud, HMI) **subscribe** do potrzebnych danych.

**Node-RED example** - to **popular tool** dla **rapid prototyping** industrial gateways. **Visual programming** makes it **accessible** nawet dla non-programmers.

**SCADA integration** - **Python example** pokazuje jak **parse MQTT topics** i **update industrial databases**. **Topic parsing** pozwala **automatically route** data do **appropriate systems**.

**Key advantages**:
- **Protocol bridging** - **incremental modernization** without **complete system replacement**
- **Data distribution** - **one publisher, many subscribers**
- **Network resilience** - **built-in reconnection** i **message persistence**
- **Cloud ready** - **direct integration** z **major cloud platforms**

**Practical deployment**: **start small** z **single gateway**, **add more** as needed. **MQTT scales** very well.

**Czas**: 8-9 minut z live code examples i practical deployment scenarios.

</InstructorNotes>

</Slide>

</SlideContainer>
